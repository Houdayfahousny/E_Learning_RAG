[
  "Java Introduction\n\nJava is a popular programming language, created in 1995.\n\nIt is owned by Oracle, and more than 3 billion devices run Java.\n\nIt is used for:\n\nWhen you are finished with this tutorial, you will be able to write basic Java programs and create real-life examples.\n\nIt is not necessary to have any prior programming experience.",
  "Java Getting Started\n\nAt W3Schools, you can try Java without installing anything.\n\nOur Online Java Editor runs directly in your browser, and shows both the code and the result:\n\nMain.java\n\nTry it Yourself »\n\nThis editor will be used in the entire tutorial to demonstrate the different aspects of Java.\n\nHowever, if you want to run Java on your own computer, follow the instructions below.\n\nSome PCs might have Java already installed.\n\nTo check if you have Java installed on a Windows PC, search in the start bar for Java or type the following in Command Prompt (cmd.exe):\n\nIf Java is installed, you will see something like this (depending on version):\n\nIf you do not have Java installed on your computer, you can download it at oracle.com.\n\nNote: In this tutorial, we will write Java code in a text editor. However, it is possible to write Java in an Integrated Development Environment, such as IntelliJ IDEA, Netbeans or Eclipse, which are particularly useful when managing larger collections of Java files.\n\nIn Java, every application begins with a class name, and that class must match the filename.\n\nLet's create our first Java file, called Main.java, which can be done in any text editor (like Notepad).\n\nThe file should contain a \"Hello World\" message, which is written with the following code:\n\nMain.java\n\nTry it Yourself »\n\nDon't worry if you don't understand the code above - we will discuss it in detail in later chapters. For now, focus on how to run the code above.\n\nSave the code in Notepad as \"Main.java\". Open Command Prompt (cmd.exe), navigate to the directory where you saved your file, and type \"javac Main.java\":\n\nThis will compile your code. If there are no errors in the code, the command prompt will take you to the next line. Now, type \"java Main\" to run the file:\n\nThe output should read:\n\nCongratulations! You have written and executed your first Java program.\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\n\njava version \"22.0.0\" 2024-08-21 LTS\nJava(TM) SE Runtime Environment 22.9 (build 22.0.0+13-LTS)\nJava HotSpot(TM) 64-Bit Server VM 22.9 (build 22.0.0+13-LTS, mixed mode)\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\n\nHello World\n\nExemple:\n\nC:\\Users\\Your Name>java -version\n\nExemple:\n\nC:\\Users\\Your Name>javac Main.java\n\nExemple:\n\nC:\\Users\\Your Name>java Main\n",
  "Java Syntax\n\nIn the previous chapter, we created a Java file called Main.java, and we used the following code to print \"Hello World\" to the screen:\n\nMain.java\n\nTry it Yourself »\n\nEvery line of code that runs in Java must be inside a class. And the class name should always start with an uppercase first letter. In our example, we named the class Main.\n\nNote: Java is case-sensitive: \"MyClass\" and \"myclass\" has different meaning.\n\nThe name of the java file must match the class name. When saving the file, save it using the class name and add \".java\" to the end of the filename. To run the example above on your computer, make sure that Java is properly installed: Go to the Get Started Chapter for how to install Java. The output should be:\n\nThe main() method is required and you will see it in every Java program:\n\nAny code inside the main() method will be executed. Don't worry about the keywords before and after it. You will get to know them bit by bit while reading this tutorial.\n\nFor now, just remember that every Java program has a class name which must match the filename, and that every program must contain the main() method.\n\nInside the main() method, we can use the println() method to print a line of text to the screen:\n\nTry it Yourself »\n\nNote: The curly braces {} marks the beginning and the end of a block of code.\n\nSystem is a built-in Java class that contains useful members, such as out, which is short for \"output\". The println() method, short for \"print line\", is used to print a value to the screen (or a file).\n\nDon't worry too much about how System, out and println() works. Just know that you need them together to print stuff to the screen.\n\nYou should also note that each code statement must end with a semicolon (;).\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\npublic static void main(String[] args)\n\npublic static void main(String[] args) {\n  System.out.println(\"Hello World\");\n}\n\nMain.java\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\nclass\n\nHello World\n\nmain()\npublic static void main(String[] args)\n\nmain()\nclass\nmain()\nmain()\nprintln()\npublic static void main(String[] args) {\n  System.out.println(\"Hello World\");\n}\n\n{}\nSystem\nout\nprintln()\nSystem\nout\nprintln()\n;",
  "Java Output / Print\n\nYou learned from the previous chapter that you can use the println() method to output values or print text in Java:\n\nTry it Yourself »\n\nYou can add as many println() methods as you want. Note that it will add a new line for each method:\n\nTry it Yourself »\n\nText must be wrapped inside double quotations marks \"\".\n\nIf you forget the double quotes, an error occurs:\n\nTry it Yourself »\n\nThere is also a print() method, which is similar to println().\n\nThe only difference is that it does not insert a new line at the end of the output:\n\nTry it Yourself »\n\nNote that we add an extra space (after \"Hello World!\" in the example above) for better readability.\n\nIn this tutorial, we will only use println() as it makes the code output easier to read.\n\nSystem.out.println(\"Hello World!\");\n\nSystem.out.println(\"Hello World!\");\nSystem.out.println(\"I am learning Java.\");\nSystem.out.println(\"It is awesome!\");\n\nSystem.out.println(\"This sentence will work!\");\nSystem.out.println(This sentence will produce an error);\nSystem.out.print(\"Hello World! \");\nSystem.out.print(\"I will print on the same line.\");\n\nprintln()\nSystem.out.println(\"Hello World!\");\n\nprintln()\nSystem.out.println(\"Hello World!\");\nSystem.out.println(\"I am learning Java.\");\nSystem.out.println(\"It is awesome!\");\n\n\"\"\nSystem.out.println(\"This sentence will work!\");\nSystem.out.println(This sentence will produce an error);\nprint()\nprintln()\nSystem.out.print(\"Hello World! \");\nSystem.out.print(\"I will print on the same line.\");\n\nprintln()",
  "Java Output / Print\n\nYou learned from the previous chapter that you can use the println() method to output values or print text in Java:\n\nTry it Yourself »\n\nYou can add as many println() methods as you want. Note that it will add a new line for each method:\n\nTry it Yourself »\n\nText must be wrapped inside double quotations marks \"\".\n\nIf you forget the double quotes, an error occurs:\n\nTry it Yourself »\n\nThere is also a print() method, which is similar to println().\n\nThe only difference is that it does not insert a new line at the end of the output:\n\nTry it Yourself »\n\nNote that we add an extra space (after \"Hello World!\" in the example above) for better readability.\n\nIn this tutorial, we will only use println() as it makes the code output easier to read.\n\nSystem.out.println(\"Hello World!\");\n\nSystem.out.println(\"Hello World!\");\nSystem.out.println(\"I am learning Java.\");\nSystem.out.println(\"It is awesome!\");\n\nSystem.out.println(\"This sentence will work!\");\nSystem.out.println(This sentence will produce an error);\nSystem.out.print(\"Hello World! \");\nSystem.out.print(\"I will print on the same line.\");\n\nprintln()\nSystem.out.println(\"Hello World!\");\n\nprintln()\nSystem.out.println(\"Hello World!\");\nSystem.out.println(\"I am learning Java.\");\nSystem.out.println(\"It is awesome!\");\n\n\"\"\nSystem.out.println(\"This sentence will work!\");\nSystem.out.println(This sentence will produce an error);\nprint()\nprintln()\nSystem.out.print(\"Hello World! \");\nSystem.out.print(\"I will print on the same line.\");\n\nprintln()",
  "Java Output Numbers\n\nYou can also use the println() method to print numbers.\n\nHowever, unlike text, we don't put numbers inside double quotes:\n\nTry it Yourself »\n\nYou can also perform mathematical calculations inside the println() method:\n\nTry it Yourself »\n\nTry it Yourself »\n\nSystem.out.println(3);\nSystem.out.println(358);\nSystem.out.println(50000);\nSystem.out.println(3 + 3);\nSystem.out.println(2 * 5);\nprintln()\nSystem.out.println(3);\nSystem.out.println(358);\nSystem.out.println(50000);\nprintln()\nSystem.out.println(3 + 3);\nSystem.out.println(2 * 5);",
  "Java Comments\n\nComments can be used to explain Java code, and to make it more readable. It can also be used to prevent execution when testing alternative code.\n\nSingle-line comments start with two forward slashes (//).\n\nAny text between // and the end of the line is ignored by Java (will not be executed).\n\nThis example uses a single-line comment before a line of code:\n\nTry it Yourself »\n\nThis example uses a single-line comment at the end of a line of code:\n\nTry it Yourself »\n\nMulti-line comments start with /* and ends with */.\n\nAny text between /* and */ will be ignored by Java.\n\nThis example uses a multi-line comment (a comment block) to explain the code:\n\nTry it Yourself »\n\nIt's up to you which one you use. Normally, we use // for short comments, and /* */ for longer.\n\n// This is a comment\nSystem.out.println(\"Hello World\");\n\nSystem.out.println(\"Hello World\"); // This is a comment\n\n/* The code below will print the words Hello World\nto the screen, and it is amazing */\nSystem.out.println(\"Hello World\");\n\n//\n//\n// This is a comment\nSystem.out.println(\"Hello World\");\n\nSystem.out.println(\"Hello World\"); // This is a comment\n\n/*\n*/\n/*\n*/\n/* The code below will print the words Hello World\nto the screen, and it is amazing */\nSystem.out.println(\"Hello World\");\n\n//\n/* */",
  "Java Variables\n\nVariables are containers for storing data values.\n\nIn Java, there are different types of variables, for example:\n\nTo create a variable in Java, you need to:\n\nHere's the basic syntax:\n\nFor example, if you want to store some text, you can use a String:\n\nCreate a variable called name of type String and assign it the value \"John\". Then we use println() to print the name variable:\n\nTry it Yourself »\n\nTo create a variable that should store a number, you can use int:\n\nCreate a variable called myNum of type int and assign it the value 15:\n\nTry it Yourself »\n\nYou can also declare a variable without assigning the value, and assign the value later:\n\nTry it Yourself »\n\nNote that if you assign a new value to an existing variable, it will overwrite the previous value:\n\nChange the value of myNum from 15 to 20:\n\nTry it Yourself »\n\nIf you don't want others (or yourself) to overwrite existing values, use the final keyword (this will declare the variable as \"final\" or \"constant\", which means unchangeable and read-only):\n\nTry it Yourself »\n\nA demonstration of how to declare variables of other types:\n\nYou will learn more about data types in the next section.\n\ntype variableName = value;\n\nString name = \"John\";\nSystem.out.println(name);\n\nint myNum = 15;\nSystem.out.println(myNum);\n\nint myNum;\nmyNum = 15;\nSystem.out.println(myNum);\n\nint myNum = 15;\nmyNum = 20;  // myNum is now 20\nSystem.out.println(myNum);\n\nfinal int myNum = 15;\nmyNum = 20;  // will generate an error: cannot assign a value to a final variable\n\nint myNum = 5;\nfloat myFloatNum = 5.99f;\nchar myLetter = 'D';\nboolean myBool = true;\nString myText = \"Hello\";\n\nString\nint\nfloat\nchar\nboolean\nint\nString\nx\nage\nname\n=\ntype variableName = value;\n\nString\nString\nprintln()\nString name = \"John\";\nSystem.out.println(name);\n\nint\nint\nint myNum = 15;\nSystem.out.println(myNum);\n\nint myNum;\nmyNum = 15;\nSystem.out.println(myNum);\n\nmyNum\n15\n20\nint myNum = 15;\nmyNum = 20;  // myNum is now 20\nSystem.out.println(myNum);\n\nfinal\nfinal int myNum = 15;\nmyNum = 20;  // will generate an error: cannot assign a value to a final variable\n\nint myNum = 5;\nfloat myFloatNum = 5.99f;\nchar myLetter = 'D';\nboolean myBool = true;\nString myText = \"Hello\";\n",
  "Java Variables\n\nVariables are containers for storing data values.\n\nIn Java, there are different types of variables, for example:\n\nTo create a variable in Java, you need to:\n\nHere's the basic syntax:\n\nFor example, if you want to store some text, you can use a String:\n\nCreate a variable called name of type String and assign it the value \"John\". Then we use println() to print the name variable:\n\nTry it Yourself »\n\nTo create a variable that should store a number, you can use int:\n\nCreate a variable called myNum of type int and assign it the value 15:\n\nTry it Yourself »\n\nYou can also declare a variable without assigning the value, and assign the value later:\n\nTry it Yourself »\n\nNote that if you assign a new value to an existing variable, it will overwrite the previous value:\n\nChange the value of myNum from 15 to 20:\n\nTry it Yourself »\n\nIf you don't want others (or yourself) to overwrite existing values, use the final keyword (this will declare the variable as \"final\" or \"constant\", which means unchangeable and read-only):\n\nTry it Yourself »\n\nA demonstration of how to declare variables of other types:\n\nYou will learn more about data types in the next section.\n\ntype variableName = value;\n\nString name = \"John\";\nSystem.out.println(name);\n\nint myNum = 15;\nSystem.out.println(myNum);\n\nint myNum;\nmyNum = 15;\nSystem.out.println(myNum);\n\nint myNum = 15;\nmyNum = 20;  // myNum is now 20\nSystem.out.println(myNum);\n\nfinal int myNum = 15;\nmyNum = 20;  // will generate an error: cannot assign a value to a final variable\n\nint myNum = 5;\nfloat myFloatNum = 5.99f;\nchar myLetter = 'D';\nboolean myBool = true;\nString myText = \"Hello\";\n\nString\nint\nfloat\nchar\nboolean\nint\nString\nx\nage\nname\n=\ntype variableName = value;\n\nString\nString\nprintln()\nString name = \"John\";\nSystem.out.println(name);\n\nint\nint\nint myNum = 15;\nSystem.out.println(myNum);\n\nint myNum;\nmyNum = 15;\nSystem.out.println(myNum);\n\nmyNum\n15\n20\nint myNum = 15;\nmyNum = 20;  // myNum is now 20\nSystem.out.println(myNum);\n\nfinal\nfinal int myNum = 15;\nmyNum = 20;  // will generate an error: cannot assign a value to a final variable\n\nint myNum = 5;\nfloat myFloatNum = 5.99f;\nchar myLetter = 'D';\nboolean myBool = true;\nString myText = \"Hello\";\n",
  "Java Print Variables\n\nThe println() method is often used to display variables.\n\nTo combine both text and a variable, use the + character:\n\nTry it Yourself »\n\nYou can also use the + character to add a variable to another variable:\n\nTry it Yourself »\n\nFor numeric values, the + character works as a mathematical operator (notice that we use int (integer) variables here):\n\nTry it Yourself »\n\nFrom the example above, you can expect:\n\nString name = \"John\";\nSystem.out.println(\"Hello \" + name);\n\nString firstName = \"John \";\nString lastName = \"Doe\";\nString fullName = firstName + lastName;\nSystem.out.println(fullName);\n\nint x = 5;\nint y = 6;\nSystem.out.println(x + y); // Print the value of x + y\n\nprintln()\n+\nString name = \"John\";\nSystem.out.println(\"Hello \" + name);\n\n+\nString firstName = \"John \";\nString lastName = \"Doe\";\nString fullName = firstName + lastName;\nSystem.out.println(fullName);\n\n+\nint\nint x = 5;\nint y = 6;\nSystem.out.println(x + y); // Print the value of x + y\n\nprintln()",
  "Java Declare Multiple Variables\n\nTo declare more than one variable of the same type, you can use a comma-separated list:\n\nInstead of writing:\n\nYou can simply write:\n\nTry it Yourself »\n\nYou can also assign the same value to multiple variables in one line:\n\nTry it Yourself »\n\nint x = 5;\nint y = 6;\nint z = 50;\nSystem.out.println(x + y + z);\n\nint x = 5, y = 6, z = 50;\nSystem.out.println(x + y + z);\n\nint x, y, z;\nx = y = z = 50;\nSystem.out.println(x + y + z);\nint x = 5;\nint y = 6;\nint z = 50;\nSystem.out.println(x + y + z);\n\nint x = 5, y = 6, z = 50;\nSystem.out.println(x + y + z);\n\nint x, y, z;\nx = y = z = 50;\nSystem.out.println(x + y + z);",
  "Java Identifiers\n\nAll Java variables must be identified with unique names.\n\nThese unique names are called identifiers.\n\nIdentifiers can be short names (like x and y) or more descriptive names (age, sum, totalVolume).\n\nNote: It is recommended to use descriptive names in order to create understandable and maintainable code:\n\nTry it Yourself »\n\nThe general rules for naming variables are:\n\n// Good\nint minutesPerHour = 60;\n\n// OK, but not so easy to understand what m actually is\nint m = 60;\n\n// Good\nint minutesPerHour = 60;\n\n// OK, but not so easy to understand what m actually is\nint m = 60;\n\nint\nboolean",
  "Java Variables - Examples\n\nOften in our examples, we simplify variable names to match their data type (myInt or myNum for int types, myChar for char types, and so on). This is done to avoid confusion.\n\nHowever, for a practical example of using variables, we have created a program that stores different data about a college student:\n\nTry it Yourself »\n\nIn this real-life example, we create a program to calculate the area of a rectangle (by multiplying the length and width):\n\nTry it Yourself »\n\n// Student data\nString studentName = \"John Doe\";\nint studentID = 15;\nint studentAge = 23;\nfloat studentFee = 75.25f;\nchar studentGrade = 'B';\n\n// Print variables\nSystem.out.println(\"Student name: \" + studentName);\nSystem.out.println(\"Student id: \" + studentID);\nSystem.out.println(\"Student age: \" + studentAge);\nSystem.out.println(\"Student fee: \" + studentFee);\nSystem.out.println(\"Student grade: \" + studentGrade);\n// Create integer variables\nint length = 4;\nint width = 6;\nint area;\n\n// Calculate the area of a rectangle\narea = length * width;\n\n// Print variables\nSystem.out.println(\"Length is: \" + length);\nSystem.out.println(\"Width is: \" + width);\nSystem.out.println(\"Area of the rectangle is: \" + area);\nint\nchar\n// Student data\nString studentName = \"John Doe\";\nint studentID = 15;\nint studentAge = 23;\nfloat studentFee = 75.25f;\nchar studentGrade = 'B';\n\n// Print variables\nSystem.out.println(\"Student name: \" + studentName);\nSystem.out.println(\"Student id: \" + studentID);\nSystem.out.println(\"Student age: \" + studentAge);\nSystem.out.println(\"Student fee: \" + studentFee);\nSystem.out.println(\"Student grade: \" + studentGrade);\n// Create integer variables\nint length = 4;\nint width = 6;\nint area;\n\n// Calculate the area of a rectangle\narea = length * width;\n\n// Print variables\nSystem.out.println(\"Length is: \" + length);\nSystem.out.println(\"Width is: \" + width);\nSystem.out.println(\"Area of the rectangle is: \" + area);",
  "Java Data Types\n\nAs explained in the previous chapter, a variable in Java must be a specified data type:\n\nTry it Yourself »\n\nData types are divided into two groups:\n\nA primitive data type specifies the type of a variable and the kind of values it can hold.\n\nThere are eight primitive data types in Java:\n\nint myNum = 5;               // Integer (whole number)\nfloat myFloatNum = 5.99f;    // Floating point number\nchar myLetter = 'D';         // Character\nboolean myBool = true;       // Boolean\nString myText = \"Hello\";     // String\n\nint myNum = 5;               // Integer (whole number)\nfloat myFloatNum = 5.99f;    // Floating point number\nchar myLetter = 'D';         // Character\nboolean myBool = true;       // Boolean\nString myText = \"Hello\";     // String\n\nbyte\nshort\nint\nlong\nfloat\ndouble\nboolean\nchar\nString\nbyte\nshort\nint\nlong\nfloat\ndouble\nboolean\nchar",
  "Java Data Types\n\nAs explained in the previous chapter, a variable in Java must be a specified data type:\n\nTry it Yourself »\n\nData types are divided into two groups:\n\nA primitive data type specifies the type of a variable and the kind of values it can hold.\n\nThere are eight primitive data types in Java:\n\nint myNum = 5;               // Integer (whole number)\nfloat myFloatNum = 5.99f;    // Floating point number\nchar myLetter = 'D';         // Character\nboolean myBool = true;       // Boolean\nString myText = \"Hello\";     // String\n\nint myNum = 5;               // Integer (whole number)\nfloat myFloatNum = 5.99f;    // Floating point number\nchar myLetter = 'D';         // Character\nboolean myBool = true;       // Boolean\nString myText = \"Hello\";     // String\n\nbyte\nshort\nint\nlong\nfloat\ndouble\nboolean\nchar\nString\nbyte\nshort\nint\nlong\nfloat\ndouble\nboolean\nchar",
  "Java Numbers\n\nPrimitive number types are divided into two groups:\n\nInteger types stores whole numbers, positive or negative (such as 123 or -456), without decimals. Valid types are byte, short, int and long. Which type you should use, depends on the numeric value.\n\nFloating point types represents numbers with a fractional part, containing one or more decimals. There are two types: float and double.\n\nEven though there are many numeric types in Java, the most used for numbers are int (for whole numbers) and double (for floating point numbers). However, we will describe them all as you continue to read.\n\nThe byte data type can store whole numbers from -128 to 127. This can be used instead of int or other integer types to save memory when you are certain that the value will be within -128 and 127:\n\nTry it Yourself »\n\nThe short data type can store whole numbers from -32768 to 32767:\n\nTry it Yourself »\n\nThe int data type can store whole numbers from -2147483648 to 2147483647. In general, and in our tutorial, the int data type is the preferred data type when we create variables with a numeric value.\n\nTry it Yourself »\n\nThe long data type can store whole numbers from -9223372036854775808 to 9223372036854775807. This is used when int is not large enough to store the value. Note that you should end the value with an \"L\":\n\nTry it Yourself »\n\nYou should use a floating point type whenever you need a number with a decimal, such as 9.99 or 3.14515.\n\nThe float and double data types can store fractional numbers. Note that you should end the value with an \"f\" for floats and \"d\" for doubles:\n\nTry it Yourself »\n\nTry it Yourself »\n\nUse float or double?\n\nThe precision of a floating point value indicates how many digits the value can have after the decimal point. The precision of float is only six or seven decimal digits, while double variables have a precision of about 16 digits. Therefore it is safer to use double for most calculations.\n\nA floating point number can also be a scientific number with an \"e\" to indicate the power of 10:\n\nTry it Yourself »\n\nbyte myNum = 100;\nSystem.out.println(myNum);\n\nshort myNum = 5000;\nSystem.out.println(myNum);\n\nint myNum = 100000;\nSystem.out.println(myNum);\n\nlong myNum = 15000000000L;\nSystem.out.println(myNum);\n\nfloat myNum = 5.75f;\nSystem.out.println(myNum);\n\ndouble myNum = 19.99d;\nSystem.out.println(myNum);\n\nfloat f1 = 35e3f;\ndouble d1 = 12E4d;\nSystem.out.println(f1);\nSystem.out.println(d1);\n\nbyte\nshort\nint\nlong\nfloat\ndouble\nint\ndouble\nbyte\nint\nbyte myNum = 100;\nSystem.out.println(myNum);\n\nshort\nshort myNum = 5000;\nSystem.out.println(myNum);\n\nint\nint\nint myNum = 100000;\nSystem.out.println(myNum);\n\nlong\nlong myNum = 15000000000L;\nSystem.out.println(myNum);\n\nfloat\ndouble\nfloat myNum = 5.75f;\nSystem.out.println(myNum);\n\ndouble myNum = 19.99d;\nSystem.out.println(myNum);\n\nfloat\ndouble\nfloat\ndouble\ndouble\nfloat f1 = 35e3f;\ndouble d1 = 12E4d;\nSystem.out.println(f1);\nSystem.out.println(d1);\n",
  "Java Boolean Data Types\n\nVery often in programming, you will need a data type that can only have one of two values, like:\n\nFor this, Java has a boolean data type, which can only take the values true or false:\n\nTry it Yourself »\n\nBoolean values are mostly used for conditional testing.\n\nYou will learn much more about booleans and conditions later in this tutorial.\n\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false\n\nboolean\ntrue\nfalse\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false\n",
  "Java Characters\n\nThe char data type is used to store a single character. The character must be surrounded by single quotes, like 'A' or 'c':\n\nTry it Yourself »\n\nAlternatively, if you are familiar with ASCII values, you can use those to display certain characters:\n\nTry it Yourself »\n\nTip: A list of all ASCII values can be found in our ASCII Table Reference.\n\nThe String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:\n\nTry it Yourself »\n\nThe String type is so much used and integrated in Java, that some call it \"the special ninth type\".\n\nA String in Java is actually a non-primitive data type, because it refers to an object. The String object has methods that are used to perform certain operations on strings. Don't worry if you don't understand the term \"object\" just yet. We will learn more about strings and objects in a later chapter.\n\nchar myGrade = 'B';\nSystem.out.println(myGrade);\n\nchar myVar1 = 65, myVar2 = 66, myVar3 = 67;\nSystem.out.println(myVar1);\nSystem.out.println(myVar2);\nSystem.out.println(myVar3);\n\nString greeting = \"Hello World\";\nSystem.out.println(greeting);\n\nchar\nchar myGrade = 'B';\nSystem.out.println(myGrade);\n\nchar myVar1 = 65, myVar2 = 66, myVar3 = 67;\nSystem.out.println(myVar1);\nSystem.out.println(myVar2);\nSystem.out.println(myVar3);\n\nString\nString greeting = \"Hello World\";\nSystem.out.println(greeting);\n",
  "Java Data Types Example\n\nHere's a real-life example of using different data types, to calculate and output the total cost of a number of items:\n\nTry it Yourself »\n\n// Create variables of different data types\nint items = 50;\nfloat costPerItem = 9.99f;\nfloat totalCost = items * costPerItem;\nchar currency = '$';\n\n// Print variables\nSystem.out.println(\"Number of items: \" + items);\nSystem.out.println(\"Cost per item: \" + costPerItem + currency);\nSystem.out.println(\"Total cost = \" + totalCost + currency);\n// Create variables of different data types\nint items = 50;\nfloat costPerItem = 9.99f;\nfloat totalCost = items * costPerItem;\nchar currency = '$';\n\n// Print variables\nSystem.out.println(\"Number of items: \" + items);\nSystem.out.println(\"Cost per item: \" + costPerItem + currency);\nSystem.out.println(\"Total cost = \" + totalCost + currency);",
  "Java Non-Primitive Data Types\n\nNon-primitive data types are called reference types because they refer to objects.\n\nThe main differences between primitive and non-primitive data types are:\n\nExamples of non-primitive types are Strings, Arrays, Classes etc. You will learn more about these in a later chapter.\n\nString\nint\nString\nnull",
  "Java Type Casting\n\nType casting is when you assign a value of one primitive data type to another type.\n\nIn Java, there are two types of casting:\n\nWidening casting is done automatically when passing a smaller size type to a larger size type:\n\nTry it Yourself »\n\nNarrowing casting must be done manually by placing the type in parentheses () in front of the value:\n\nTry it Yourself »\n\nHere's a real-life example of type casting where we create a program to calculate the percentage of a user's score in relation to the maximum score in a game.\n\nWe use type casting to make sure that the result is a floating-point value, rather than an integer:\n\nTry it Yourself »\n\npublic class Main {\n  public static void main(String[] args) {\n    int myInt = 9;\n    double myDouble = myInt; // Automatic casting: int to double\n\n    System.out.println(myInt);      // Outputs 9\n    System.out.println(myDouble);   // Outputs 9.0\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    double myDouble = 9.78d;\n    int myInt = (int) myDouble; // Manual casting: double to int\n\n    System.out.println(myDouble);   // Outputs 9.78\n    System.out.println(myInt);      // Outputs 9\n  }\n}\n\n// Set the maximum possible score in the game to 500\nint maxScore = 500;\n\n// The actual score of the user\nint userScore = 423;\n\n/* Calculate the percentage of the user's score in relation to the maximum available score.\nConvert userScore to float to make sure that the division is accurate */\nfloat percentage = (float) userScore / maxScore * 100.0f;\n\nSystem.out.println(\"User's percentage is \" + percentage);\nbyte\nshort\nchar\nint\nlong\nfloat\ndouble\ndouble\nfloat\nlong\nint\nchar\nshort\nbyte\npublic class Main {\n  public static void main(String[] args) {\n    int myInt = 9;\n    double myDouble = myInt; // Automatic casting: int to double\n\n    System.out.println(myInt);      // Outputs 9\n    System.out.println(myDouble);   // Outputs 9.0\n  }\n}\n\n()\npublic class Main {\n  public static void main(String[] args) {\n    double myDouble = 9.78d;\n    int myInt = (int) myDouble; // Manual casting: double to int\n\n    System.out.println(myDouble);   // Outputs 9.78\n    System.out.println(myInt);      // Outputs 9\n  }\n}\n\n// Set the maximum possible score in the game to 500\nint maxScore = 500;\n\n// The actual score of the user\nint userScore = 423;\n\n/* Calculate the percentage of the user's score in relation to the maximum available score.\nConvert userScore to float to make sure that the division is accurate */\nfloat percentage = (float) userScore / maxScore * 100.0f;\n\nSystem.out.println(\"User's percentage is \" + percentage);",
  "Java Operators\n\nOperators are used to perform operations on variables and values.\n\nIn the example below, we use the + operator to add together two values:\n\nTry it Yourself »\n\nAlthough the + operator is often used to add together two values, like in the example above, it can also be used to add together a variable and a value, or a variable and another variable:\n\nTry it Yourself »\n\nJava divides the operators into the following groups:\n\nArithmetic operators are used to perform common mathematical operations.\n\nAssignment operators are used to assign values to variables.\n\nIn the example below, we use the assignment operator (=) to assign the value 10 to a variable called x:\n\nTry it Yourself »\n\nThe addition assignment operator (+=) adds a value to a variable:\n\nTry it Yourself »\n\nA list of all assignment operators:\n\nComparison operators are used to compare two values (or variables). This is important in programming, because it helps us to find answers and make decisions.\n\nThe return value of a comparison is either true or false. These values are known as Boolean values, and you will learn more about them in the Booleans and If..Else chapter.\n\nIn the following example, we use the greater than operator (>) to find out if 5 is greater than 3:\n\nTry it Yourself »\n\nYou can also test for true or false values with logical operators.\n\nLogical operators are used to determine the logic between variables or values:\n\nint x = 100 + 50;\n\nint sum1 = 100 + 50;        // 150 (100 + 50)\nint sum2 = sum1 + 250;      // 400 (150 + 250)\nint sum3 = sum2 + sum2;     // 800 (400 + 400)\n\nint x = 10;\n\nint x = 10;\nx += 5;\n\nint x = 5;\nint y = 3;\nSystem.out.println(x > y); // returns true, because 5 is higher than 3\n\n+\nint x = 100 + 50;\n\n+\nint sum1 = 100 + 50;        // 150 (100 + 50)\nint sum2 = sum1 + 250;      // 400 (150 + 250)\nint sum3 = sum2 + sum2;     // 800 (400 + 400)\n\n=\nint x = 10;\n\n+=\nint x = 10;\nx += 5;\n\ntrue\nfalse\n>\nint x = 5;\nint y = 3;\nSystem.out.println(x > y); // returns true, because 5 is higher than 3\n\ntrue\nfalse",
  "Java Strings\n\nStrings are used for storing text.\n\nA String variable contains a collection of characters surrounded by double quotes:\n\nCreate a variable of type String and assign it a value:\n\nTry it Yourself »\n\nA String in Java is actually an object, which contain methods that can perform certain operations on strings. For example, the length of a string can be found with the length() method:\n\nTry it Yourself »\n\nThere are many string methods available, for example toUpperCase() and toLowerCase():\n\nTry it Yourself »\n\nThe indexOf() method returns the index (the position) of the first occurrence of a specified text in a string (including whitespace):\n\nTry it Yourself »\n\nJava counts positions from zero.0 is the first position in a string, 1 is the second, 2 is the third ...\n\nFor a complete reference of String methods, go to our Java String Methods Reference.\n\nThe reference contains descriptions and examples of all string methods.\n\nString greeting = \"Hello\";\n\nString txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nSystem.out.println(\"The length of the txt string is: \" + txt.length());\n\nString txt = \"Hello World\";\nSystem.out.println(txt.toUpperCase());   // Outputs \"HELLO WORLD\"\nSystem.out.println(txt.toLowerCase());   // Outputs \"hello world\"\n\nString txt = \"Please locate where 'locate' occurs!\";\nSystem.out.println(txt.indexOf(\"locate\")); // Outputs 7\n\nString\nString\nString greeting = \"Hello\";\n\nlength()\nString txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nSystem.out.println(\"The length of the txt string is: \" + txt.length());\n\ntoUpperCase()\ntoLowerCase()\nString txt = \"Hello World\";\nSystem.out.println(txt.toUpperCase());   // Outputs \"HELLO WORLD\"\nSystem.out.println(txt.toLowerCase());   // Outputs \"hello world\"\n\nindexOf()\nString txt = \"Please locate where 'locate' occurs!\";\nSystem.out.println(txt.indexOf(\"locate\")); // Outputs 7\n",
  "Java Strings\n\nStrings are used for storing text.\n\nA String variable contains a collection of characters surrounded by double quotes:\n\nCreate a variable of type String and assign it a value:\n\nTry it Yourself »\n\nA String in Java is actually an object, which contain methods that can perform certain operations on strings. For example, the length of a string can be found with the length() method:\n\nTry it Yourself »\n\nThere are many string methods available, for example toUpperCase() and toLowerCase():\n\nTry it Yourself »\n\nThe indexOf() method returns the index (the position) of the first occurrence of a specified text in a string (including whitespace):\n\nTry it Yourself »\n\nJava counts positions from zero.0 is the first position in a string, 1 is the second, 2 is the third ...\n\nFor a complete reference of String methods, go to our Java String Methods Reference.\n\nThe reference contains descriptions and examples of all string methods.\n\nString greeting = \"Hello\";\n\nString txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nSystem.out.println(\"The length of the txt string is: \" + txt.length());\n\nString txt = \"Hello World\";\nSystem.out.println(txt.toUpperCase());   // Outputs \"HELLO WORLD\"\nSystem.out.println(txt.toLowerCase());   // Outputs \"hello world\"\n\nString txt = \"Please locate where 'locate' occurs!\";\nSystem.out.println(txt.indexOf(\"locate\")); // Outputs 7\n\nString\nString\nString greeting = \"Hello\";\n\nlength()\nString txt = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nSystem.out.println(\"The length of the txt string is: \" + txt.length());\n\ntoUpperCase()\ntoLowerCase()\nString txt = \"Hello World\";\nSystem.out.println(txt.toUpperCase());   // Outputs \"HELLO WORLD\"\nSystem.out.println(txt.toLowerCase());   // Outputs \"hello world\"\n\nindexOf()\nString txt = \"Please locate where 'locate' occurs!\";\nSystem.out.println(txt.indexOf(\"locate\")); // Outputs 7\n",
  "Java String Concatenation\n\nThe + operator can be used between strings to combine them. This is called concatenation:\n\nTry it Yourself »\n\nNote that we have added an empty text (\" \") to create a space between firstName and lastName on print.\n\nYou can also use the concat() method to concatenate two strings:\n\nTry it Yourself »\n\nString firstName = \"John\";\nString lastName = \"Doe\";\nSystem.out.println(firstName + \" \" + lastName);\n\nString firstName = \"John \";\nString lastName = \"Doe\";\nSystem.out.println(firstName.concat(lastName));\n\n+\nString firstName = \"John\";\nString lastName = \"Doe\";\nSystem.out.println(firstName + \" \" + lastName);\n\nconcat()\nString firstName = \"John \";\nString lastName = \"Doe\";\nSystem.out.println(firstName.concat(lastName));\n",
  "Java Numbers and Strings\n\nWARNING!\n\nJava uses the + operator for both addition and concatenation.\n\nNumbers are added. Strings are concatenated.\n\nIf you add two numbers, the result will be a number:\n\nTry it Yourself »\n\nIf you add two strings, the result will be a string concatenation:\n\nTry it Yourself »\n\nIf you add a number and a string, the result will be a string concatenation:\n\nTry it Yourself »\n\nint x = 10;\nint y = 20;\nint z = x + y;  // z will be 30 (an integer/number)\n\nString x = \"10\";\nString y = \"20\";\nString z = x + y;  // z will be 1020 (a String)\n\nString x = \"10\";\nint y = 20;\nString z = x + y;  // z will be 1020 (a String)\n\n+\nint x = 10;\nint y = 20;\nint z = x + y;  // z will be 30 (an integer/number)\n\nString x = \"10\";\nString y = \"20\";\nString z = x + y;  // z will be 1020 (a String)\n\nString x = \"10\";\nint y = 20;\nString z = x + y;  // z will be 1020 (a String)\n",
  "Java Special Characters\n\nBecause strings must be written within quotes, Java will misunderstand this string, and generate an error:\n\nThe solution to avoid this problem, is to use the backslash escape character.\n\nThe backslash (\\) escape character turns special characters into string characters:\n\nThe sequence \\\" inserts a double quote in a string: Example String txt = \"We are the so-called \\\"Vikings\\\" from the north.\"; Try it Yourself » The sequence \\' inserts a single quote in a string: Example String txt = \"It\\'s alright.\"; Try it Yourself » The sequence \\\\ inserts a single backslash in a string: Example String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nExample String txt = \"We are the so-called \\\"Vikings\\\" from the north.\"; Try it Yourself » The sequence \\' inserts a single quote in a string: Example String txt = \"It\\'s alright.\"; Try it Yourself » The sequence \\\\ inserts a single backslash in a string: Example String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nTry it Yourself »\n\nThe sequence \\' inserts a single quote in a string: Example String txt = \"It\\'s alright.\"; Try it Yourself » The sequence \\\\ inserts a single backslash in a string: Example String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nExample String txt = \"It\\'s alright.\"; Try it Yourself » The sequence \\\\ inserts a single backslash in a string: Example String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nTry it Yourself »\n\nThe sequence \\\\ inserts a single backslash in a string: Example String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nExample String txt = \"The character \\\\ is called backslash.\"; Try it Yourself » Other common escape sequences that are valid in Java are: Code Result Try it \\n New Line Try it » \\r Carriage Return Try it » \\t Tab Try it » \\b Backspace Try it » \\f Form Feed ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nTry it Yourself »\n\nOther common escape sequences that are valid in Java are:\n\nString txt = \"We are the so-called \"Vikings\" from the north.\";\n\nString txt = \"We are the so-called \\\"Vikings\\\" from the north.\";\n\nString txt = \"It\\'s alright.\";\n\nString txt = \"The character \\\\ is called backslash.\";\n\nString txt = \"We are the so-called \"Vikings\" from the north.\";\n\n\\\n\\\"\nString txt = \"We are the so-called \\\"Vikings\\\" from the north.\";\n\n\\'\nString txt = \"It\\'s alright.\";\n\n\\\\\nString txt = \"The character \\\\ is called backslash.\";\n",
  "Java Math\n\nThe Java Math class has many methods that allows you to perform mathematical tasks on numbers.\n\nThe Math.max(x,y) method can be used to find the highest value of x and y:\n\nTry it Yourself »\n\nThe Math.min(x,y) method can be used to find the lowest value of x and y:\n\nTry it Yourself »\n\nThe Math.sqrt(x) method returns the square root of x:\n\nTry it Yourself »\n\nThe Math.abs(x) method returns the absolute (positive) value of x:\n\nTry it Yourself »\n\nMath.random() returns a random number between 0.0 (inclusive), and 1.0 (exclusive):\n\nTry it Yourself »\n\nTo get more control over the random number, for example, if you only want a random number between 0 and 100, you can use the following formula:\n\nTry it Yourself »\n\nFor a complete reference of Math methods, go to our Java Math Methods Reference.\n\nMath.max(5, 10);\n\nMath.min(5, 10);\n\nMath.sqrt(64);\n\nMath.abs(-4.7);\n\nMath.random();\n\nint randomNum = (int)(Math.random() * 101);  // 0 to 100\nMath.max(x,y)\nMath.max(5, 10);\n\nMath.min(x,y)\nMath.min(5, 10);\n\nMath.sqrt(x)\nMath.sqrt(64);\n\nMath.abs(x)\nMath.abs(-4.7);\n\nMath.random()\nMath.random();\n\nint randomNum = (int)(Math.random() * 101);  // 0 to 100",
  "Java Booleans\n\nVery often, in programming, you will need a data type that can only have one of two values, like:\n\nFor this, Java has a boolean data type, which can store true or false values.\n\nA boolean type is declared with the boolean keyword and can only take the values true or false:\n\nTry it Yourself »\n\nHowever, it is more common to return boolean values from boolean expressions, for conditional testing (see below).\n\nA Boolean expression returns a boolean value: true or false.\n\nThis is useful to build logic, and find answers.\n\nFor example, you can use a comparison operator, such as the greater than (>) operator, to find out if an expression (or a variable) is true or false:\n\nTry it Yourself »\n\nOr even easier:\n\nTry it Yourself »\n\nIn the examples below, we use the equal to (==) operator to evaluate an expression:\n\nTry it Yourself »\n\nTry it Yourself »\n\nLet's think of a \"real life example\" where we need to find out if a person is old enough to vote.\n\nIn the example below, we use the >= comparison operator to find out if the age (25) is greater than OR equal to the voting age limit, which is set to 18:\n\nTry it Yourself »\n\nCool, right? An even better approach (since we are on a roll now), would be to wrap the code above in an if...else statement, so we can perform different actions depending on the result:\n\nOutput \"Old enough to vote!\" if myAge is greater than or equal to 18. Otherwise output \"Not old enough to vote.\":\n\nTry it Yourself »\n\nBooleans are the basis for all Java comparisons and conditions.\n\nYou will learn more about conditions (if...else) in the next chapter.\n\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false\n\nint x = 10;\nint y = 9;\nSystem.out.println(x > y); // returns true, because 10 is higher than 9\n\nSystem.out.println(10 > 9); // returns true, because 10 is higher than 9\n\nint x = 10;\nSystem.out.println(x == 10); // returns true, because the value of x is equal to 10\n\nSystem.out.println(10 == 15); // returns false, because 10 is not equal to 15\n\nint myAge = 25;\nint votingAge = 18;\nSystem.out.println(myAge >= votingAge);\nint myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\n  System.out.println(\"Old enough to vote!\");\n} else {\n  System.out.println(\"Not old enough to vote.\");\n}\nboolean\ntrue\nfalse\nboolean\ntrue\nfalse\nboolean isJavaFun = true;\nboolean isFishTasty = false;\nSystem.out.println(isJavaFun);     // Outputs true\nSystem.out.println(isFishTasty);   // Outputs false\n\ntrue\nfalse\n>\nint x = 10;\nint y = 9;\nSystem.out.println(x > y); // returns true, because 10 is higher than 9\n\nSystem.out.println(10 > 9); // returns true, because 10 is higher than 9\n\n==\nint x = 10;\nSystem.out.println(x == 10); // returns true, because the value of x is equal to 10\n\nSystem.out.println(10 == 15); // returns false, because 10 is not equal to 15\n\n>=\n25\n18\nint myAge = 25;\nint votingAge = 18;\nSystem.out.println(myAge >= votingAge);\nif...else\nmyAge\n18\nint myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\n  System.out.println(\"Old enough to vote!\");\n} else {\n  System.out.println(\"Not old enough to vote.\");\n}\nif...else",
  "Java If ... Else\n\nYou already know that Java supports the usual logical conditions from mathematics:\n\nYou can use these conditions to perform different actions for different decisions.\n\nJava has the following conditional statements:\n\nUse the if statement to specify a block of Java code to be executed if a condition is true.\n\nNote that if is in lowercase letters. Uppercase letters (If or IF) will generate an error.\n\nIn the example below, we test two values to find out if 20 is greater than 18. If the condition is true, print some text:\n\nTry it Yourself »\n\nWe can also test variables:\n\nTry it Yourself »\n\nIn the example above we use two variables, x and y, to test whether x is greater than y (using the > operator). As x is 20, and y is 18, and we know that 20 is greater than 18, we print to the screen that \"x is greater than y\".\n\nif (condition) {\n  // block of code to be executed if the condition is true\n}\n\nif (20 > 18) {\n  System.out.println(\"20 is greater than 18\");\n}\n\nint x = 20;\nint y = 18;\nif (x > y) {\n  System.out.println(\"x is greater than y\");\n}\n\nif\nelse\nelse if\nswitch\nif\ntrue\nif (condition) {\n  // block of code to be executed if the condition is true\n}\n\nif\ntrue\nif (20 > 18) {\n  System.out.println(\"20 is greater than 18\");\n}\n\nint x = 20;\nint y = 18;\nif (x > y) {\n  System.out.println(\"x is greater than y\");\n}\n\n>",
  "Java If ... Else\n\nYou already know that Java supports the usual logical conditions from mathematics:\n\nYou can use these conditions to perform different actions for different decisions.\n\nJava has the following conditional statements:\n\nUse the if statement to specify a block of Java code to be executed if a condition is true.\n\nNote that if is in lowercase letters. Uppercase letters (If or IF) will generate an error.\n\nIn the example below, we test two values to find out if 20 is greater than 18. If the condition is true, print some text:\n\nTry it Yourself »\n\nWe can also test variables:\n\nTry it Yourself »\n\nIn the example above we use two variables, x and y, to test whether x is greater than y (using the > operator). As x is 20, and y is 18, and we know that 20 is greater than 18, we print to the screen that \"x is greater than y\".\n\nif (condition) {\n  // block of code to be executed if the condition is true\n}\n\nif (20 > 18) {\n  System.out.println(\"20 is greater than 18\");\n}\n\nint x = 20;\nint y = 18;\nif (x > y) {\n  System.out.println(\"x is greater than y\");\n}\n\nif\nelse\nelse if\nswitch\nif\ntrue\nif (condition) {\n  // block of code to be executed if the condition is true\n}\n\nif\ntrue\nif (20 > 18) {\n  System.out.println(\"20 is greater than 18\");\n}\n\nint x = 20;\nint y = 18;\nif (x > y) {\n  System.out.println(\"x is greater than y\");\n}\n\n>",
  "Java Else\n\nUse the else statement to specify a block of code to be executed if the condition is false.\n\nTry it Yourself »\n\nIn the example above, time (20) is greater than 18, so the condition is false. Because of this, we move on to the else condition and print to the screen \"Good evening\". If the time was less than 18, the program would print \"Good day\".\n\nif (condition) {\n  // block of code to be executed if the condition is true\n} else {\n  // block of code to be executed if the condition is false\n}\n\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nelse\nfalse\nif (condition) {\n  // block of code to be executed if the condition is true\n} else {\n  // block of code to be executed if the condition is false\n}\n\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nfalse\nelse",
  "Java Else If\n\nUse the else if statement to specify a new condition if the first condition is false.\n\nTry it Yourself »\n\nIn the example above, time (22) is greater than 10, so the first condition is false. The next condition, in the else if statement, is also false, so we move on to the else condition since condition1 and condition2 is both false - and print to the screen \"Good evening\".\n\nHowever, if the time was 14, our program would print \"Good day.\"\n\nif (condition1) {\n  // block of code to be executed if condition1 is true\n} else if (condition2) {\n  // block of code to be executed if the condition1 is false and condition2 is true\n} else {\n  // block of code to be executed if the condition1 is false and condition2 is false\n}\n\nint time = 22;\nif (time < 10) {\n  System.out.println(\"Good morning.\");\n} else if (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nelse if\nfalse\nif (condition1) {\n  // block of code to be executed if condition1 is true\n} else if (condition2) {\n  // block of code to be executed if the condition1 is false and condition2 is true\n} else {\n  // block of code to be executed if the condition1 is false and condition2 is false\n}\n\nint time = 22;\nif (time < 10) {\n  System.out.println(\"Good morning.\");\n} else if (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n// Outputs \"Good evening.\"\n\nfalse\nelse if\nfalse\nelse\nfalse",
  "Java Short Hand If...Else (Ternary Operator)\n\nThere is also a short-hand if else, which is known as the ternary operator because it consists of three operands.\n\nIt can be used to replace multiple lines of code with a single line, and is most often used to replace simple if else statements:\n\nInstead of writing:\n\nTry it Yourself »\n\nYou can simply write:\n\nTry it Yourself »\n\nvariable = (condition) ? expressionTrue :  expressionFalse;\n\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n\nint time = 20;\nString result = (time < 18) ? \"Good day.\" : \"Good evening.\";\nSystem.out.println(result);\n\nvariable = (condition) ? expressionTrue :  expressionFalse;\n\nint time = 20;\nif (time < 18) {\n  System.out.println(\"Good day.\");\n} else {\n  System.out.println(\"Good evening.\");\n}\n\nint time = 20;\nString result = (time < 18) ? \"Good day.\" : \"Good evening.\";\nSystem.out.println(result);\n",
  "Java If ... Else Examples\n\nThis example shows how you can use if..else to \"open a door\" if the user enters the correct code:\n\nTry it Yourself »\n\nThis example shows how you can use if..else to find out if a number is positive or negative:\n\nTry it Yourself »\n\nFind out if a person is old enough to vote:\n\nTry it Yourself »\n\nFind out if a number is even or odd:\n\nTry it Yourself »\n\nint doorCode = 1337;\n\nif (doorCode == 1337) {\n  System.out.println(\"Correct code. The door is now open.\");\n} else {\n  System.out.println(\"Wrong code. The door remains closed.\");\n}\nint myNum = 10; // Is this a positive or negative number?\n\nif (myNum > 0) {\n  System.out.println(\"The value is a positive number.\");\n} else if (myNum < 0) {\n  System.out.println(\"The value is a negative number.\");\n} else {\n  System.out.println(\"The value is 0.\");\n}\nint myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\n  System.out.println(\"Old enough to vote!\");\n} else {\n  System.out.println(\"Not old enough to vote.\");\n}\nint myNum = 5;\n\nif (myNum % 2 == 0) {\n  System.out.println(myNum + \" is even\");\n} else {\n  System.out.println(myNum + \" is odd\");\n} \nint doorCode = 1337;\n\nif (doorCode == 1337) {\n  System.out.println(\"Correct code. The door is now open.\");\n} else {\n  System.out.println(\"Wrong code. The door remains closed.\");\n}\nint myNum = 10; // Is this a positive or negative number?\n\nif (myNum > 0) {\n  System.out.println(\"The value is a positive number.\");\n} else if (myNum < 0) {\n  System.out.println(\"The value is a negative number.\");\n} else {\n  System.out.println(\"The value is 0.\");\n}\nint myAge = 25;\nint votingAge = 18;\n\nif (myAge >= votingAge) {\n  System.out.println(\"Old enough to vote!\");\n} else {\n  System.out.println(\"Not old enough to vote.\");\n}\nint myNum = 5;\n\nif (myNum % 2 == 0) {\n  System.out.println(myNum + \" is even\");\n} else {\n  System.out.println(myNum + \" is odd\");\n} ",
  "Java Switch\n\nInstead of writing many if..else statements, you can use the switch statement.\n\nThe switch statement selects one of many code blocks to be executed:\n\nThis is how it works:\n\nThe example below uses the weekday number to calculate the weekday name:\n\nTry it Yourself »\n\nWhen Java reaches a break keyword, it breaks out of the switch block.\n\nThis will stop the execution of more code and case testing inside the block.\n\nWhen a match is found, and the job is done, it's time for a break. There is no need for more testing.\n\nA break can save a lot of execution time because it \"ignores\" the execution of all the rest of the code in the switch block.\n\nThe default keyword specifies some code to run if there is no case match:\n\nTry it Yourself »\n\nNote that if the default statement is used as the last statement in a switch block, it does not need a break.\n\nswitch(expression) {\n  case x:\n    // code block\n    break;\n  case y:\n    // code block\n    break;\n  default:\n    // code block\n}\n\nint day = 4;\nswitch (day) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  case 2:\n    System.out.println(\"Tuesday\");\n    break;\n  case 3:\n    System.out.println(\"Wednesday\");\n    break;\n  case 4:\n    System.out.println(\"Thursday\");\n    break;\n  case 5:\n    System.out.println(\"Friday\");\n    break;\n  case 6:\n    System.out.println(\"Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Sunday\");\n    break;\n}\n// Outputs \"Thursday\" (day 4)\n\nint day = 4;\nswitch (day) {\n  case 6:\n    System.out.println(\"Today is Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Today is Sunday\");\n    break;\n  default:\n    System.out.println(\"Looking forward to the Weekend\");\n}\n// Outputs \"Looking forward to the Weekend\"\n\nif..else\nswitch\nswitch\nswitch(expression) {\n  case x:\n    // code block\n    break;\n  case y:\n    // code block\n    break;\n  default:\n    // code block\n}\n\nswitch\ncase\nbreak\ndefault\nint day = 4;\nswitch (day) {\n  case 1:\n    System.out.println(\"Monday\");\n    break;\n  case 2:\n    System.out.println(\"Tuesday\");\n    break;\n  case 3:\n    System.out.println(\"Wednesday\");\n    break;\n  case 4:\n    System.out.println(\"Thursday\");\n    break;\n  case 5:\n    System.out.println(\"Friday\");\n    break;\n  case 6:\n    System.out.println(\"Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Sunday\");\n    break;\n}\n// Outputs \"Thursday\" (day 4)\n\nbreak\ndefault\nint day = 4;\nswitch (day) {\n  case 6:\n    System.out.println(\"Today is Saturday\");\n    break;\n  case 7:\n    System.out.println(\"Today is Sunday\");\n    break;\n  default:\n    System.out.println(\"Looking forward to the Weekend\");\n}\n// Outputs \"Looking forward to the Weekend\"\n\ndefault",
  "Java While Loop\n\nLoops can execute a block of code as long as a specified condition is reached.\n\nLoops are handy because they save time, reduce errors, and they make code more readable.\n\nThe while loop loops through a block of code as long as a specified condition is true:\n\nIn the example below, the code in the loop will run, over and over again, as long as a variable (i) is less than 5:\n\nTry it Yourself »\n\nNote: Do not forget to increase the variable used in the condition (i++), otherwise the loop will never end!\n\nDo you wonder why we used the letter i in the example above? It's a counter variable and a common choice in simple loops because it's short, traditional, and stands for 'index' or 'iterator'.\n\nThis example counts down from 3 to 1 and then displays \"Happy New Year!!\" at the end:\n\nTry it Yourself »\n\nwhile (condition) {\n  // code block to be executed\n}\n\nint i = 0;\nwhile (i < 5) {\n  System.out.println(i);\n  i++;\n}\n\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");\nwhile\ntrue\nwhile (condition) {\n  // code block to be executed\n}\n\ni\nint i = 0;\nwhile (i < 5) {\n  System.out.println(i);\n  i++;\n}\n\ni++\ni\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");",
  "Java While Loop\n\nLoops can execute a block of code as long as a specified condition is reached.\n\nLoops are handy because they save time, reduce errors, and they make code more readable.\n\nThe while loop loops through a block of code as long as a specified condition is true:\n\nIn the example below, the code in the loop will run, over and over again, as long as a variable (i) is less than 5:\n\nTry it Yourself »\n\nNote: Do not forget to increase the variable used in the condition (i++), otherwise the loop will never end!\n\nDo you wonder why we used the letter i in the example above? It's a counter variable and a common choice in simple loops because it's short, traditional, and stands for 'index' or 'iterator'.\n\nThis example counts down from 3 to 1 and then displays \"Happy New Year!!\" at the end:\n\nTry it Yourself »\n\nwhile (condition) {\n  // code block to be executed\n}\n\nint i = 0;\nwhile (i < 5) {\n  System.out.println(i);\n  i++;\n}\n\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");\nwhile\ntrue\nwhile (condition) {\n  // code block to be executed\n}\n\ni\nint i = 0;\nwhile (i < 5) {\n  System.out.println(i);\n  i++;\n}\n\ni++\ni\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");",
  "Java Do/While Loop\n\nThe do/while loop is a variant of the while loop. This loop will execute the code block once, before checking if the condition is true. Then it will repeat the loop as long as the condition is true.\n\nNote: The semicolon ; after the while condition is required!\n\nThe example below uses a do/while loop. The loop will always be executed at least once, even if the condition is false, because the code block is executed before the condition is tested:\n\nTry it Yourself »\n\nDo not forget to increase the variable used in the condition (i++), otherwise the loop will never end!\n\nIn the example above, the condition i < 5 was true at the beginning, so the loop executed multiple times. But what if the condition is false right from the start?\n\nIn the example below, the variable i starts at 10, so the condition i < 5 is false immediately - yet the do/while loop still runs once:\n\nTry it Yourself »\n\nSummary: The do/while loop always runs at least once, even if the condition is already false. This is different from a regular while loop, which would skip the loop entirely if the condition is false at the start.\n\nThis behavior makes do/while useful when you want to ensure something happens at least once, like showing a message or asking for user input.\n\ndo {\n  // code block to be executed\n}\nwhile (condition);\n\nint i = 0;do {\n  System.out.println(i);\n  i++;\n}\nwhile (i < 5);\n\nint i = 10;do {  System.out.println(\"i is \" + i);  i++;} while (i < 5);\n\ndo/while\nwhile\ndo {\n  // code block to be executed\n}\nwhile (condition);\n\n;\nwhile\ndo/while\nint i = 0;do {\n  System.out.println(i);\n  i++;\n}\nwhile (i < 5);\n\ni++\ni < 5\ni\ni < 5\ndo/while\nint i = 10;do {  System.out.println(\"i is \" + i);  i++;} while (i < 5);\n\ndo/while\nwhile\ndo/while",
  "Java While Loop Examples\n\nTo demonstrate a practical example of the while loop, we have created a simple \"countdown\" program:\n\nTry it Yourself »\n\nTo demonstrate a practical example of the while loop combined with an if else statement, let's say we play a game of Yatzy:\n\nPrint \"Yatzy!\" If the dice number is 6:\n\nTry it Yourself »\n\nIf the loop passes the values ranging from 1 to 5, it prints \"No Yatzy\". Whenever it passes the value 6, it prints \"Yatzy!\".\n\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");\nint dice = 1;\n\nwhile (dice <= 6) {\n  if (dice < 6) {\n    System.out.println(\"No Yatzy.\");\n  } else {\n    System.out.println(\"Yatzy!\");\n  }\n  dice = dice + 1;\n}\nint countdown = 3;\n\nwhile (countdown > 0) {\n  System.out.println(countdown);\n  countdown--;\n}\n\nSystem.out.println(\"Happy New Year!!\");\nint dice = 1;\n\nwhile (dice <= 6) {\n  if (dice < 6) {\n    System.out.println(\"No Yatzy.\");\n  } else {\n    System.out.println(\"Yatzy!\");\n  }\n  dice = dice + 1;\n}",
  "Java For Loop\n\nWhen you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop:\n\nStatement 1 is executed (one time) before the execution of the code block.\n\nStatement 2 defines the condition for executing the code block.\n\nStatement 3 is executed (every time) after the code block has been executed.\n\nThe example below will print the numbers 0 to 4:\n\nTry it Yourself »\n\nThis example prints even values between 0 and 10:\n\nTry it Yourself »\n\nThis example calculates the sum of numbers from 1 to 5:\n\nTry it Yourself »\n\nThis example prints a countdown from 5 to 1:\n\nTry it Yourself »\n\nfor (statement 1; statement 2; statement 3) {\n  // code block to be executed\n}\nfor (int i = 0; i < 5; i++) {  System.out.println(i);}\n\nfor (int i = 0; i <= 10; i = i + 2) {  System.out.println(i);}\n\nint sum = 0;for (int i = 1; i <= 5; i++) {  sum = sum + i;}System.out.println(\"Sum is \" + sum);\n\nfor (int i = 5; i > 0; i--) {  System.out.println(i);}\n\nfor\nwhile\nfor (statement 1; statement 2; statement 3) {\n  // code block to be executed\n}\nfor (int i = 0; i < 5; i++) {  System.out.println(i);}\n\nint i = 0\ni < 5\ni++\nfor (int i = 0; i <= 10; i = i + 2) {  System.out.println(i);}\n\nint sum = 0;for (int i = 1; i <= 5; i++) {  sum = sum + i;}System.out.println(\"Sum is \" + sum);\n\nfor (int i = 5; i > 0; i--) {  System.out.println(i);}\n",
  "Java For Loop\n\nWhen you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop:\n\nStatement 1 is executed (one time) before the execution of the code block.\n\nStatement 2 defines the condition for executing the code block.\n\nStatement 3 is executed (every time) after the code block has been executed.\n\nThe example below will print the numbers 0 to 4:\n\nTry it Yourself »\n\nThis example prints even values between 0 and 10:\n\nTry it Yourself »\n\nThis example calculates the sum of numbers from 1 to 5:\n\nTry it Yourself »\n\nThis example prints a countdown from 5 to 1:\n\nTry it Yourself »\n\nfor (statement 1; statement 2; statement 3) {\n  // code block to be executed\n}\nfor (int i = 0; i < 5; i++) {  System.out.println(i);}\n\nfor (int i = 0; i <= 10; i = i + 2) {  System.out.println(i);}\n\nint sum = 0;for (int i = 1; i <= 5; i++) {  sum = sum + i;}System.out.println(\"Sum is \" + sum);\n\nfor (int i = 5; i > 0; i--) {  System.out.println(i);}\n\nfor\nwhile\nfor (statement 1; statement 2; statement 3) {\n  // code block to be executed\n}\nfor (int i = 0; i < 5; i++) {  System.out.println(i);}\n\nint i = 0\ni < 5\ni++\nfor (int i = 0; i <= 10; i = i + 2) {  System.out.println(i);}\n\nint sum = 0;for (int i = 1; i <= 5; i++) {  sum = sum + i;}System.out.println(\"Sum is \" + sum);\n\nfor (int i = 5; i > 0; i--) {  System.out.println(i);}\n",
  "Java Nested Loops\n\nIt is also possible to place a loop inside another loop. This is called a nested loop.\n\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":\n\nTry it Yourself »\n\nThis example uses nested loops to print a simple multiplication table (1 to 3):\n\nTry it Yourself »\n\nNested loops are useful when working with tables, matrices, or multi-dimensional data structures.\n\n// Outer loop\nfor (int i = 1; i <= 2; i++) {\n  System.out.println(\"Outer: \" + i); // Executes 2 times\n  \n  // Inner loop\n  for (int j = 1; j <= 3; j++) {\n    System.out.println(\" Inner: \" + j); // Executes 6 times (2 * 3)\n  }\n} \nfor (int i = 1; i <= 3; i++) {  for (int j = 1; j <= 3; j++) {    System.out.print(i * j + \" \");  }  System.out.println();}\n\n\n1 2 3\n2 4 6\n3 6 9\n\n// Outer loop\nfor (int i = 1; i <= 2; i++) {\n  System.out.println(\"Outer: \" + i); // Executes 2 times\n  \n  // Inner loop\n  for (int j = 1; j <= 3; j++) {\n    System.out.println(\" Inner: \" + j); // Executes 6 times (2 * 3)\n  }\n} \nfor (int i = 1; i <= 3; i++) {  for (int j = 1; j <= 3; j++) {    System.out.print(i * j + \" \");  }  System.out.println();}\n\n1 2 3\n2 4 6\n3 6 9",
  "Java For Each Loop\n\nThere is also a \"for-each\" loop, which is used exclusively to loop through elements in an array (or other data structures):\n\nThe following example outputs all elements in the cars array, using a \"for-each\" loop:\n\nTry it Yourself »\n\nNote: Don't worry if you don't understand the example above. You will learn more about Arrays in the Java Arrays chapter.\n\nfor (type variableName : arrayName) {\n  // code block to be executed\n}\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}\n\nfor (type variableName : arrayName) {\n  // code block to be executed\n}\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}\n",
  "Java For Loop Examples\n\nTo demonstrate a practical example of the for loop, let's create a program that counts to 100 by tens:\n\nTry it Yourself »\n\nIn this example, we create a program that only print even values between 0 and 10:\n\nTry it Yourself »\n\nAnd in this example, we create a program that prints the multiplication table for a specified number:\n\nTry it Yourself »\n\nfor (int i = 0; i <= 100; i += 10) {\n  System.out.println(i);\n} \nfor (int i = 0; i <= 10; i = i + 2) {\n  System.out.println(i);\n}\nint number = 2;\n\n// Print the multiplication table for the number 2\nfor (int i = 1; i <= 10; i++) {\n  System.out.println(number + \" x \" + i + \" = \" + (number * i));\n} \nfor (int i = 0; i <= 100; i += 10) {\n  System.out.println(i);\n} \nfor (int i = 0; i <= 10; i = i + 2) {\n  System.out.println(i);\n}\nint number = 2;\n\n// Print the multiplication table for the number 2\nfor (int i = 1; i <= 10; i++) {\n  System.out.println(number + \" x \" + i + \" = \" + (number * i));\n} ",
  "Java Break and Continue\n\nYou have already seen the break statement used in an earlier chapter of this tutorial. It was used to \"jump out\" of a switch statement.\n\nThe break statement can also be used to jump out of a loop.\n\nThis example stops the loop when i is equal to 4:\n\nTry it Yourself »\n\nThe continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.\n\nThis example skips the value of 4:\n\nTry it Yourself »\n\nYou can also use break and continue in while loops:\n\nTry it Yourself »\n\nTry it Yourself »\n\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    break;\n  }\n  System.out.println(i);\n}\n\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    continue;\n  }\n  System.out.println(i);\n}\n\nint i = 0;\nwhile (i < 10) {\n  System.out.println(i);\n  i++;\n  if (i == 4) {\n    break;\n  }\n}\n\nint i = 0;\nwhile (i < 10) {\n  if (i == 4) {\n    i++;\n    continue;\n  }\n  System.out.println(i);\n  i++;\n}\n\nbreak\nswitch\nbreak\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    break;\n  }\n  System.out.println(i);\n}\n\ncontinue\nfor (int i = 0; i < 10; i++) {\n  if (i == 4) {\n    continue;\n  }\n  System.out.println(i);\n}\n\nbreak\ncontinue\nint i = 0;\nwhile (i < 10) {\n  System.out.println(i);\n  i++;\n  if (i == 4) {\n    break;\n  }\n}\n\nint i = 0;\nwhile (i < 10) {\n  if (i == 4) {\n    i++;\n    continue;\n  }\n  System.out.println(i);\n  i++;\n}\n",
  "Java Arrays\n\nArrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.\n\nTo declare an array, define the variable type with square brackets:\n\nWe have now declared a variable that holds an array of strings. To insert values to it, you can place the values in a comma-separated list, inside curly braces:\n\nTo create an array of integers, you could write:\n\nYou can access an array element by referring to the index number.\n\nThis statement accesses the value of the first element in cars:\n\nTry it Yourself »\n\nNote: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\n\nTo change the value of a specific element, refer to the index number:\n\nTry it Yourself »\n\nTo find out how many elements an array has, use the length property:\n\nTry it Yourself »\n\nString[] cars;\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nint[] myNum = {10, 20, 30, 40};\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars[0]);\n// Outputs Volvo\n\ncars[0] = \"Opel\";\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\ncars[0] = \"Opel\";\nSystem.out.println(cars[0]);\n// Now outputs Opel instead of Volvo\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars.length);\n// Outputs 4\n\nString[] cars;\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nint[] myNum = {10, 20, 30, 40};\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars[0]);\n// Outputs Volvo\n\ncars[0] = \"Opel\";\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\ncars[0] = \"Opel\";\nSystem.out.println(cars[0]);\n// Now outputs Opel instead of Volvo\n\nlength\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars.length);\n// Outputs 4\n",
  "Java Arrays\n\nArrays are used to store multiple values in a single variable, instead of declaring separate variables for each value.\n\nTo declare an array, define the variable type with square brackets:\n\nWe have now declared a variable that holds an array of strings. To insert values to it, you can place the values in a comma-separated list, inside curly braces:\n\nTo create an array of integers, you could write:\n\nYou can access an array element by referring to the index number.\n\nThis statement accesses the value of the first element in cars:\n\nTry it Yourself »\n\nNote: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\n\nTo change the value of a specific element, refer to the index number:\n\nTry it Yourself »\n\nTo find out how many elements an array has, use the length property:\n\nTry it Yourself »\n\nString[] cars;\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nint[] myNum = {10, 20, 30, 40};\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars[0]);\n// Outputs Volvo\n\ncars[0] = \"Opel\";\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\ncars[0] = \"Opel\";\nSystem.out.println(cars[0]);\n// Now outputs Opel instead of Volvo\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars.length);\n// Outputs 4\n\nString[] cars;\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\n\nint[] myNum = {10, 20, 30, 40};\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars[0]);\n// Outputs Volvo\n\ncars[0] = \"Opel\";\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\ncars[0] = \"Opel\";\nSystem.out.println(cars[0]);\n// Now outputs Opel instead of Volvo\n\nlength\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nSystem.out.println(cars.length);\n// Outputs 4\n",
  "Java Arrays Loop\n\nYou can loop through the array elements with the for loop, and use the length property to specify how many times the loop should run.\n\nThe following example outputs all elements in the cars array:\n\nTry it Yourself »\n\nThere is also a \"for-each\" loop, which is used exclusively to loop through elements in arrays:\n\nThe following example outputs all elements in the cars array, using a \"for-each\" loop:\n\nTry it Yourself »\n\nThe example above can be read like this: for each String element (called i - as in index) in cars, print out the value of i.\n\nIf you compare the for loop and for-each loop, you will see that the for-each method is easier to write, it does not require a counter (using the length property), and it is more readable.\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (int i = 0; i < cars.length; i++) {\n  System.out.println(cars[i]);\n}\n\nfor (type variable : arrayname) {\n  ...\n}\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}\n\nfor\nlength\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (int i = 0; i < cars.length; i++) {\n  System.out.println(cars[i]);\n}\n\nfor (type variable : arrayname) {\n  ...\n}\n\nString[] cars = {\"Volvo\", \"BMW\", \"Ford\", \"Mazda\"};\nfor (String i : cars) {\n  System.out.println(i);\n}\n\nString\nfor",
  "Java Arrays - Real-Life Examples\n\nTo demonstrate a practical example of using arrays, let's create a program that calculates the average of different ages:\n\nTry it Yourself »\n\nAnd in this example, we create a program that finds the lowest age among different ages:\n\nTry it Yourself »\n\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Loop through the elements of the array\nfor (int age : ages) {\n  sum += age;\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nSystem.out.println(\"The average age is: \" + avg);\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\n// Get the length of the array\nint length = ages.length;\n\n// Create a 'lowest age' variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int age : ages) {\n  // Check if the current age is smaller than the current 'lowest age'\n  if (lowestAge > age) {\n    // If the smaller age is found, update 'lowest age' with that element\n    lowestAge = age;\n  }\n}\n\n// Output the value of the lowest age\nSystem.out.println(\"The lowest age in the array is: \" + lowestAge);\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Loop through the elements of the array\nfor (int age : ages) {\n  sum += age;\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nSystem.out.println(\"The average age is: \" + avg);\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\n// Get the length of the array\nint length = ages.length;\n\n// Create a 'lowest age' variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int age : ages) {\n  // Check if the current age is smaller than the current 'lowest age'\n  if (lowestAge > age) {\n    // If the smaller age is found, update 'lowest age' with that element\n    lowestAge = age;\n  }\n}\n\n// Output the value of the lowest age\nSystem.out.println(\"The lowest age in the array is: \" + lowestAge);",
  "Java Multi-Dimensional Arrays\n\nA multidimensional array is an array of arrays.\n\nMultidimensional arrays are useful when you want to store data as a tabular form, like a table with rows and columns.\n\nTo create a two-dimensional array, add each array within its own set of curly braces:\n\nmyNumbers is now an array with two arrays as its elements.\n\nTo access the elements of the myNumbers array, specify two indexes: one for the array, and one for the element inside that array. This example accesses the third element (2) in the second array (1) of myNumbers:\n\nTry it Yourself »\n\nRemember that: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.\n\nYou can also change the value of an element:\n\nTry it Yourself »\n\nYou can also use a for loop inside another for loop to get the elements of a two-dimensional array (we still have to point to the two indexes):\n\nTry it Yourself »\n\nOr you could just use a for-each loop, which is considered easier to read and write:\n\nTry it Yourself »\n\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\n\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nSystem.out.println(myNumbers[1][2]); // Outputs 7\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nmyNumbers[1][2] = 9;\nSystem.out.println(myNumbers[1][2]); // Outputs 9 instead of 7\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nfor (int i = 0; i < myNumbers.length; ++i) {\n  for (int j = 0; j < myNumbers[i].length; ++j) {\n    System.out.println(myNumbers[i][j]);\n  }}\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nfor (int[] row : myNumbers) {\n  for (int i : row) {\n    System.out.println(i);\n  }\n}\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\n\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nSystem.out.println(myNumbers[1][2]); // Outputs 7\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nmyNumbers[1][2] = 9;\nSystem.out.println(myNumbers[1][2]); // Outputs 9 instead of 7\nfor loop\nfor loop\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nfor (int i = 0; i < myNumbers.length; ++i) {\n  for (int j = 0; j < myNumbers[i].length; ++j) {\n    System.out.println(myNumbers[i][j]);\n  }}\nint[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} };\nfor (int[] row : myNumbers) {\n  for (int i : row) {\n    System.out.println(i);\n  ",
  "Java Methods\n\nA method is a block of code which only runs when it is called.\n\nYou can pass data, known as parameters, into a method.\n\nMethods are used to perform certain actions, and they are also known as functions.\n\nWhy use methods? To reuse code: define the code once, and use it many times.\n\nA method must be declared within a class. It is defined with the name of the method, followed by parentheses (). Java provides some pre-defined methods, such as System.out.println(), but you can also create your own methods to perform certain actions:\n\nCreate a method inside Main:\n\nTo call a method in Java, write the method's name followed by two parentheses () and a semicolon;\n\nIn the following example, myMethod() is used to print a text (the action), when it is called:\n\nInside main, call the myMethod() method:\n\nTry it Yourself »\n\nA method can also be called multiple times:\n\nTry it Yourself »\n\nIn the next chapter, Method Parameters, you will learn how to pass data (parameters) into a method.\n\npublic class Main {\n  static void myMethod() {\n    // code to be executed\n  }\n}\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"I just got executed!\"\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n    myMethod();\n    myMethod();\n  }\n}\n\n// I just got executed!\n// I just got executed!\n// I just got executed!\n\nSystem.out.println()\npublic class Main {\n  static void myMethod() {\n    // code to be executed\n  }\n}\n\nmyMethod()\nstatic\nvoid\nmyMethod()\nmain\n\nmyMethod()\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"I just got executed!\"\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"I just got executed!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n    myMethod();\n    myMethod();\n  }\n}\n\n// I just got executed!\n// I just got executed!\n// I just got executed!\n",
  "Java Method Parameters\n\nInformation can be passed to methods as a parameter. Parameters act as variables inside the method.\n\nParameters are specified after the method name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.\n\nThe following example has a method that takes a String called fname as parameter. When the method is called, we pass along a first name, which is used inside the method to print the full name:\n\nTry it Yourself »\n\nWhen a parameter is passed to the method, it is called an argument. So, from the example above: fname is a parameter, while Liam, Jenny and Anja are arguments.\n\nYou can have as many parameters as you like:\n\nTry it Yourself »\n\nNote that when you are working with multiple parameters, the method call must have the same number of arguments as there are parameters, and the arguments must be passed in the same order.\n\nIt is common to use if...else statements inside methods:\n\nTry it Yourself »\n\npublic class Main {\n  static void myMethod(String fname) {\n    System.out.println(fname + \" Refsnes\");\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\");\n    myMethod(\"Jenny\");\n    myMethod(\"Anja\");\n  }\n}\n// Liam Refsnes\n// Jenny Refsnes\n// Anja Refsnes\n\npublic class Main {\n  static void myMethod(String fname, int age) {\n    System.out.println(fname + \" is \" + age);\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\", 5);\n    myMethod(\"Jenny\", 8);\n    myMethod(\"Anja\", 31);\n  }\n}\n\n// Liam is 5\n// Jenny is 8\n// Anja is 31\npublic class Main {\n\n  // Create a checkAge() method with an integer variable called age\n  static void checkAge(int age) {\n\n    // If age is less than 18, print \"access denied\"\n    if (age < 18) {\n      System.out.println(\"Access denied - You are not old enough!\");\n\n    // If age is greater than, or equal to, 18, print \"access granted\"\n    } else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n\n  }\n\n  public static void main(String[] args) {\n    checkAge(20); // Call the checkAge method and pass along an age of 20\n  }\n}\n\n// Outputs \"Access granted - You are old enough!\"\n\nString\npublic class Main {\n  static void myMethod(String fname) {\n    System.out.println(fname + \" Refsnes\");\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\");\n    myMethod(\"Jenny\");\n    myMethod(\"Anja\");\n  }\n}\n// Liam Refsnes\n// Jenny Refsnes\n// Anja Refsnes\n\nfname\nLiam\nJenny\nAnja\npublic class Main {\n  static void myMethod(String fname, int age) {\n    System.out.println(fname + \" is \" + age);\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\", 5);\n    myMethod(\"Jenny\", 8);\n    myMethod(\"Anja\", 31);\n  }\n}\n\n// Liam is 5\n// Jenny is 8\n// Anja is 31\nif...else\npublic class Main {\n\n  // Create a checkAge() method with an integer variable called age\n  static void checkAge(int age) {\n\n    // If age is less than 18, print \"access denied\"\n    if (age < 18) {\n      System.out.println(\"Access denied - You are not old enough!\");\n\n    // If age is greater than, or equal to, 18, print \"access granted\"\n    } else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n\n  }\n\n  public static void main(String[] args) {\n    checkAge(20); // Call the checkAge method and pass along an age of 20\n  }\n}\n\n// Outputs \"Access granted - You are old enough!\"\n",
  "Java Method Parameters\n\nInformation can be passed to methods as a parameter. Parameters act as variables inside the method.\n\nParameters are specified after the method name, inside the parentheses. You can add as many parameters as you want, just separate them with a comma.\n\nThe following example has a method that takes a String called fname as parameter. When the method is called, we pass along a first name, which is used inside the method to print the full name:\n\nTry it Yourself »\n\nWhen a parameter is passed to the method, it is called an argument. So, from the example above: fname is a parameter, while Liam, Jenny and Anja are arguments.\n\nYou can have as many parameters as you like:\n\nTry it Yourself »\n\nNote that when you are working with multiple parameters, the method call must have the same number of arguments as there are parameters, and the arguments must be passed in the same order.\n\nIt is common to use if...else statements inside methods:\n\nTry it Yourself »\n\npublic class Main {\n  static void myMethod(String fname) {\n    System.out.println(fname + \" Refsnes\");\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\");\n    myMethod(\"Jenny\");\n    myMethod(\"Anja\");\n  }\n}\n// Liam Refsnes\n// Jenny Refsnes\n// Anja Refsnes\n\npublic class Main {\n  static void myMethod(String fname, int age) {\n    System.out.println(fname + \" is \" + age);\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\", 5);\n    myMethod(\"Jenny\", 8);\n    myMethod(\"Anja\", 31);\n  }\n}\n\n// Liam is 5\n// Jenny is 8\n// Anja is 31\npublic class Main {\n\n  // Create a checkAge() method with an integer variable called age\n  static void checkAge(int age) {\n\n    // If age is less than 18, print \"access denied\"\n    if (age < 18) {\n      System.out.println(\"Access denied - You are not old enough!\");\n\n    // If age is greater than, or equal to, 18, print \"access granted\"\n    } else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n\n  }\n\n  public static void main(String[] args) {\n    checkAge(20); // Call the checkAge method and pass along an age of 20\n  }\n}\n\n// Outputs \"Access granted - You are old enough!\"\n\nString\npublic class Main {\n  static void myMethod(String fname) {\n    System.out.println(fname + \" Refsnes\");\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\");\n    myMethod(\"Jenny\");\n    myMethod(\"Anja\");\n  }\n}\n// Liam Refsnes\n// Jenny Refsnes\n// Anja Refsnes\n\nfname\nLiam\nJenny\nAnja\npublic class Main {\n  static void myMethod(String fname, int age) {\n    System.out.println(fname + \" is \" + age);\n  }\n\n  public static void main(String[] args) {\n    myMethod(\"Liam\", 5);\n    myMethod(\"Jenny\", 8);\n    myMethod(\"Anja\", 31);\n  }\n}\n\n// Liam is 5\n// Jenny is 8\n// Anja is 31\nif...else\npublic class Main {\n\n  // Create a checkAge() method with an integer variable called age\n  static void checkAge(int age) {\n\n    // If age is less than 18, print \"access denied\"\n    if (age < 18) {\n      System.out.println(\"Access denied - You are not old enough!\");\n\n    // If age is greater than, or equal to, 18, print \"access granted\"\n    } else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n\n  }\n\n  public static void main(String[] args) {\n    checkAge(20); // Call the checkAge method and pass along an age of 20\n  }\n}\n\n// Outputs \"Access granted - You are old enough!\"\n",
  "Java Return\n\nIn the previous page, we used the void keyword in all examples, which indicates that the method should not return a value.\n\nIf you want the method to return a value, you can use a primitive data type (such as int, char, etc.) instead of void, and use the return keyword inside the method:\n\nTry it Yourself »\n\nThis example returns the sum of a method's two parameters:\n\nTry it Yourself »\n\nYou can also store the result in a variable (recommended, as it is easier to read and maintain):\n\nTry it Yourself »\n\npublic class Main {\n  static int myMethod(int x) {\n    return 5 + x;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(3));\n  }\n}\n// Outputs 8 (5 + 3)\n\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(5, 3));\n  }\n}\n// Outputs 8 (5 + 3)\n\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    int z = myMethod(5, 3);\n    System.out.println(z);\n  }\n}\n// Outputs 8 (5 + 3)\n\nvoid\nint\nchar\nvoid\nreturn\npublic class Main {\n  static int myMethod(int x) {\n    return 5 + x;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(3));\n  }\n}\n// Outputs 8 (5 + 3)\n\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    System.out.println(myMethod(5, 3));\n  }\n}\n// Outputs 8 (5 + 3)\n\npublic class Main {\n  static int myMethod(int x, int y) {\n    return x + y;\n  }\n\n  public static void main(String[] args) {\n    int z = myMethod(5, 3);\n    System.out.println(z);\n  }\n}\n// Outputs 8 (5 + 3)\n",
  "Java Method Overloading\n\nWith method overloading, multiple methods can have the same name with different parameters:\n\nConsider the following example, which has two methods that add numbers of different type:\n\nTry it Yourself »\n\nInstead of defining two methods that should do the same thing, it is better to overload one.\n\nIn the example below, we overload the plusMethod method to work for both int and double:\n\nTry it Yourself »\n\nNote: Multiple methods can have the same name as long as the number and/or type of parameters are different.\n\nint myMethod(int x)\nfloat myMethod(float x)\ndouble myMethod(double x, double y)\nstatic int plusMethodInt(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethodDouble(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethodInt(8, 5);\n  double myNum2 = plusMethodDouble(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}\nstatic int plusMethod(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethod(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethod(8, 5);\n  double myNum2 = plusMethod(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}\nint myMethod(int x)\nfloat myMethod(float x)\ndouble myMethod(double x, double y)\nstatic int plusMethodInt(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethodDouble(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethodInt(8, 5);\n  double myNum2 = plusMethodDouble(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}\nplusMethod\nint\ndouble\nstatic int plusMethod(int x, int y) {\n  return x + y;\n}\n\nstatic double plusMethod(double x, double y) {\n  return x + y;\n}\n\npublic static void main(String[] args) {\n  int myNum1 = plusMethod(8, 5);\n  double myNum2 = plusMethod(4.3, 6.26);\n  System.out.println(\"int: \" + myNum1);\n  System.out.println(\"double: \" + myNum2);\n}",
  "Java Scope\n\nIn Java, variables are only accessible inside the region they are created. This is called scope.\n\nVariables declared directly inside a method are available anywhere in the method following the line of code in which they were declared:\n\nTry it Yourself »\n\nA block of code refers to all of the code between curly braces {}.\n\nVariables declared inside blocks of code are only accessible by the code between the curly braces, which follows the line in which the variable was declared:\n\nTry it Yourself »\n\nA block of code may exist on its own or it can belong to an if, while or for statement. In the case of for statements, variables declared in the statement itself are also available inside the block's scope.\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    int x = 100;\n\n    // Code here can use x\n    System.out.println(x);\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    { // This is a block\n\n      // Code here CANNOT use x\n\n      int x = 100;\n\n      // Code here CAN use x\n      System.out.println(x);\n\n    } // The block ends here\n\n  // Code here CANNOT use x\n\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    int x = 100;\n\n    // Code here can use x\n    System.out.println(x);\n  \n\n\n{}\npublic class Main {\n  public static void main(String[] args) {\n\n    // Code here CANNOT use x\n\n    { // This is a block\n\n      // Code here CANNOT use x\n\n      int x = 100;\n\n      // Code here CAN use x\n      System.out.println(x);\n\n    } // The block ends here\n\n  // Code here CANNOT use x\n\n  }\n}\nif\nwhile\nfor\nfor",
  "Java Recursion\n\nRecursion is the technique of making a function call itself. This technique provides a way to break complicated problems down into simple problems which are easier to solve.\n\nRecursion may be a bit difficult to understand. The best way to figure out how it works is to experiment with it.\n\nAdding two numbers together is easy to do, but adding a range of numbers is more complicated. In the following example, recursion is used to add a range of numbers together by breaking it down into the simple task of adding two numbers:\n\nUse recursion to add all of the numbers up to 10.\n\nTry it Yourself »\n\nWhen the sum() function is called, it adds parameter k to the sum of all numbers smaller than k and returns the result. When k becomes 0, the function just returns 0. When running, the program follows these steps:\n\nSince the function does not call itself when k is 0, the program stops there and returns the result.\n\nJust as loops can run into the problem of infinite looping, recursive functions can run into the problem of infinite recursion. Infinite recursion is when the function never stops calling itself. Every recursive function should have a halting condition, which is the condition where the function stops calling itself. In the previous example, the halting condition is when the parameter k becomes 0.\n\nIt is helpful to see a variety of different examples to better understand the concept. In this example, the function adds a range of numbers between a start and an end. The halting condition for this recursive function is when end is not greater than start:\n\nUse recursion to add all of the numbers between 5 to 10.\n\nTry it Yourself »\n\nThe developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming.\n\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(10);\n    System.out.println(result);\n  }\n  public static int sum(int k) {\n    if (k > 0) {\n      return k + sum(k - 1);\n    } else {\n      return 0;\n    }\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(5, 10);\n    System.out.println(result);\n  }\n  public static int sum(int start, int end) {\n    if (end > start) {\n      return end + sum(start, end - 1);\n    } else {\n      return end;\n    }\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(10);\n    System.out.println(result);\n  \n\n  public static int sum(int k) {\n    if (k > 0) {\n      return k + sum(k - 1);\n    } else {\n      return 0;\n    \n\n  \n\n\nsum()\nk\nk\nk\nk\npublic class Main {\n  public static void main(String[] args) {\n    int result = sum(5, 10);\n    System.out.println(result);\n  \n\n  public static int sum(int start, int end) {\n    if (end > start) {\n      return end + sum(start, end - 1);\n    } else {\n      return end;\n    }\n  }\n}",
  "Java OOP\n\nOOP stands for Object-Oriented Programming.\n\nProcedural programming is about writing procedures or methods that perform operations on the data, while object-oriented programming is about creating objects that contain both data and methods.\n\nObject-oriented programming has several advantages over procedural programming:\n\nTip: The \"Don't Repeat Yourself\" (DRY) principle is about reducing the repetition of code. You should extract out the codes that are common for the application, and place them at a single place and reuse them instead of repeating it.\n\nClasses and objects are the two main aspects of object-oriented programming.\n\nLook at the following illustration to see the difference between class and objects:\n\nFruit\n\nApple\n\nBanana\n\nMango\n\nAnother example:\n\nCar\n\nVolvo\n\nAudi\n\nToyota\n\nSo, a class is a template for objects, and an object is an instance of a class.\n\nWhen the individual objects are created, they inherit all the variables and methods from the class.\n\nYou will learn much more about classes and objects in the next chapter.",
  "Java Classes and Objects\n\nJava is an object-oriented programming language.\n\nEverything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nTo create a class, use the keyword class:\n\nCreate a class named \"Main\" with a variable x:\n\nRemember from the Java Syntax chapter that a class should always start with an uppercase first letter, and that the name of the java file should match the class name.\n\nIn Java, an object is created from a class. We have already created the class named Main, so now we can use this to create objects.\n\nTo create an object of Main, specify the class name, followed by the object name, and use the keyword new:\n\nCreate an object called \"myObj\" and print the value of x:\n\nTry it Yourself »\n\nYou can create multiple objects of one class:\n\nCreate two objects of Main:\n\nTry it Yourself »\n\nYou can also create an object of a class and access it in another class. This is often used for better organization of classes (one class has all the attributes and methods, while the other class holds the main() method (code to be executed)).\n\nRemember that the name of the java file should match the class name. In this example, we have created two files in the same directory/folder:\n\nWhen both files have been compiled:\n\nRun the Second.java file:\n\nAnd the output will be:\n\nYou will learn much more about classes and objects in the next chapters.\n\npublic class Main {\n  int x = 5;\n}\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj1 = new Main();  // Object 1\n    Main myObj2 = new Main();  // Object 2\n    System.out.println(myObj1.x);\n    System.out.println(myObj2.x);\n  }\n}\n\npublic class Main {\n  int x = 5;\n}\n\nclass Second {\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\nclass\nMain\npublic class Main {\n  int x = 5;\n}\n\n\nMain\nMain\nnew\nmyObj\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\nMain\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj1 = new Main();  // Object 1\n    Main myObj2 = new Main();  // Object 2\n    System.out.println(myObj1.x);\n    System.out.println(myObj2.x);\n  }\n}\n\nmain()\npublic class Main {\n  int x = 5;\n}\n\nclass Second {\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\n5\nExemple:\n\nC:\\Users\\Your Name>javac Main.java\nC:\\Users\\Your Name>javac Second.java\n\nExemple:\n\nC:\\Users\\Your Name>java Second\n",
  "Java Class Attributes\n\nIn the previous chapter, we used the term \"variable\" for x in the example (as shown below). It is actually an attribute of the class. Or you could say that class attributes are variables within a class:\n\nCreate a class called \"Main\" with two attributes: x and y:\n\nAnother term for class attributes is fields.\n\nYou can access attributes by creating an object of the class, and by using the dot syntax (.):\n\nThe following example will create an object of the Main class, with the name myObj. We use the x attribute on the object to print its value:\n\nCreate an object called \"myObj\" and print the value of x:\n\nTry it Yourself »\n\nYou can also modify attribute values:\n\nSet the value of x to 40:\n\nTry it Yourself »\n\nOr override existing values:\n\nChange the value of x to 25:\n\nTry it Yourself »\n\nIf you don't want the ability to override existing values, declare the attribute as final:\n\nTry it Yourself »\n\nThe final keyword is useful when you want a variable to always store the same value, like PI (3.14159...).\n\nThe final keyword is called a \"modifier\". You will learn more about these in the Java Modifiers Chapter.\n\nIf you create multiple objects of one class, you can change the attribute values in one object, without affecting the attribute values in the other:\n\nChange the value of x to 25 in myObj2, and leave x in myObj1 unchanged:\n\nTry it Yourself »\n\nYou can specify as many attributes as you want:\n\nTry it Yourself »\n\nThe next chapter will teach you how to create class methods and how to access them with objects.\n\npublic class Main {\n  int x = 5;\n  int y = 3;\n}\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  int x;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 40;\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // x is now 25\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  final int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj1 = new Main();  // Object 1\n    Main myObj2 = new Main();  // Object 2\n    myObj2.x = 25;\n    System.out.println(myObj1.x);  // Outputs 5\n    System.out.println(myObj2.x);  // Outputs 25\n  }\n}\n\npublic class Main {\n  String fname = \"John\";\n  String lname = \"Doe\";\n  int age = 24;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(\"Name: \" + myObj.fname + \" \" + myObj.lname);\n    System.out.println(\"Age: \" + myObj.age);\n  }\n}\n\nx\nMain\nx\ny\npublic class Main {\n  int x = 5;\n  int y = 3;\n}\n\n.\nMain\nmyObj\nx\nmyObj\nx\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(myObj.x);\n  }\n}\n\nx\npublic class Main {\n  int x;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 40;\n    System.out.println(myObj.x);\n  }\n}\n\nx\npublic class Main {\n  int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // x is now 25\n    System.out.println(myObj.x);\n  }\n}\n\nfinal\npublic class Main {\n  final int x = 10;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}\n\nfinal\nfinal\nx\nmyObj2\nx\nmyObj1\npublic class Main {\n  int x = 5;\n\n  public static void main(String[] args) {\n    Main myObj1 = new Main();  // Object 1\n    Main myObj2 = new Main();  // Object 2\n    myObj2.x = 25;\n    System.out.println(myObj1.x);  // Outputs 5\n    System.out.println(myObj2.x);  // Outputs 25\n  }\n}\n\npublic class Main {\n  String fname = \"John\";\n  String lname = \"Doe\";\n  int age = 24;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    System.out.println(\"Name: \" + myObj.fname + \" \" + myObj.lname);\n    System.out.println(\"Age: \" + myObj.age);\n  }\n}\n",
  "Java Class Methods\n\nYou learned from the Java Methods chapter that methods are declared within a class, and that they are used to perform certain actions:\n\nCreate a method named myMethod() in Main:\n\nmyMethod() prints a text (the action), when it is called. To call a method, write the method's name followed by two parentheses () and a semicolon;\n\nInside main, call myMethod():\n\nTry it Yourself »\n\nYou will often see Java programs that have either static or public attributes and methods.\n\nIn the example above, we created a static method, which means that it can be accessed without creating an object of the class, unlike public, which can only be accessed by objects:\n\nAn example to demonstrate the differences between static and public methods:\n\nTry it Yourself »\n\nNote: You will learn more about these keywords (called modifiers) in the Java Modifiers chapter.\n\nCreate a Car object named myCar. Call the fullThrottle() and speed() methods on the myCar object, and run the program:\n\nTry it Yourself »\n\n1) We created a custom Main class with the class keyword.\n\n2) We created the fullThrottle() and speed() methods in the Main class.\n\n3) The fullThrottle() method and the speed() method will print out some text, when they are called.\n\n4) The speed() method accepts an int parameter called maxSpeed - we will use this in 8).\n\n5) In order to use the Main class and its methods, we need to create an object of the Main Class.\n\n6) Then, go to the main() method, which you know by now is a built-in Java method that runs your program (any code inside main is executed).\n\n7) By using the new keyword we created an object with the name myCar.\n\n8) Then, we call the fullThrottle() and speed() methods on the myCar object, and run the program using the name of the object (myCar), followed by a dot (.), followed by the name of the method (fullThrottle(); and speed(200);). Notice that we add an int parameter of 200 inside the speed() method.\n\nThe dot (.) is used to access the object's attributes and methods.\n\nTo call a method in Java, write the method name followed by a set of parentheses (), followed by a semicolon (;).\n\nA class must have a matching filename (Main and Main.java).\n\nLike we specified in the Classes chapter, it is a good practice to create an object of a class and access it in another class.\n\nRemember that the name of the java file should match the class name. In this example, we have created two files in the same directory:\n\nWhen both files have been compiled:\n\nRun the Second.java file:\n\nAnd the output will be:\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n}\n\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"Hello World!\"\n\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would compile an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method on the object\n  }\n}\n\n// Create a Main class\npublic class Main {\n \n  // Create a fullThrottle() method\n  public void fullThrottle() {\n    System.out.println(\"The car is going as fast as it can!\");\n  }\n\n  // Create a speed() method and add a parameter\n  public void speed(int maxSpeed) {\n    System.out.println(\"Max speed is: \" + maxSpeed);\n  }\n\n  // Inside main, call the methods on the myCar object\n  public static void main(String[] args) {\n    Main myCar = new Main();   // Create a myCar object\n    myCar.fullThrottle();      // Call the fullThrottle() method\n    myCar.speed(200);          // Call the speed() method\n  }\n}\n\n// The car is going as fast as it can!\n// Max speed is: 200\n\npublic class Main {\n  public void fullThrottle() {\n    System.out.println(\"The car is going as fast as it can!\");\n  }\n\n  public void speed(int maxSpeed) {\n    System.out.println(\"Max speed is: \" + maxSpeed);\n  }\n}\n\nclass Second {\n  public static void main(String[] args) {\n    Main myCar = new Main();     // Create a myCar object\n    myCar.fullThrottle();      // Call the fullThrottle() method\n    myCar.speed(200);          // Call the speed() method\n  }\n}\n\nmyMethod()\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n}\n\nmyMethod()\nmain\n\nmyMethod()\npublic class Main {\n  static void myMethod() {\n    System.out.println(\"Hello World!\");\n  }\n\n  public static void main(String[] args) {\n    myMethod();\n  }\n}\n\n// Outputs \"Hello World!\"\n\nstatic\npublic\nstatic\npublic\nstatic\npublic\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would compile an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method on the object\n  }\n}\n\nmyCar\nfullThrottle()\nspeed()\nmyCar\n// Create a Main class\npublic class Main {\n \n  // Create a fullThrottle() method\n  public void fullThrottle() {\n    System.out.println(\"The car is going as fast as it can!\");\n  }\n\n  // Create a speed() method and add a parameter\n  public void speed(int maxSpeed) {\n    System.out.println(\"Max speed is: \" + maxSpeed);\n  }\n\n  // Inside main, call the methods on the myCar object\n  public static void main(String[] args) {\n    Main myCar = new Main();   // Create a myCar object\n    myCar.fullThrottle();      // Call the fullThrottle() method\n    myCar.speed(200);          // Call the speed() method\n  }\n}\n\n// The car is going as fast as it can!\n// Max speed is: 200\n\nMain\nclass\nfullThrottle()\n\nspeed()\nMain\nfullThrottle()\n\nspeed()\nspeed()\nint\n\nmaxSpeed\nMain\n\nMain\nmain()\nnew\nmyCar\nfullThrottle()\nspeed()\n\nmyCar\nmyCar\n.\nfullThrottle();\n\nspeed(200);\nint\n\nspeed()\n.\n;\nMain\npublic class Main {\n  public void fullThrottle() {\n    System.out.println(\"The car is going as fast as it can!\");\n  }\n\n  public void speed(int maxSpeed) {\n    System.out.println(\"Max speed is: \" + maxSpeed);\n  }\n}\n\nclass Second {\n  public static void main(String[] args) {\n    Main myCar = new Main();     // Create a myCar object\n    myCar.fullThrottle();      // Call the fullThrottle() method\n    myCar.speed(200);          // Call the speed() method\n  }\n}\n\nThe car is going as fast as it can!\nMax speed is: 200\n\nExemple:\n\nC:\\Users\\Your Name>javac Main.java\nC:\\Users\\Your Name>javac Second.java\n\nExemple:\n\nC:\\Users\\Your Name>java Second\n",
  "Java Constructors\n\nA constructor in Java is a special method that is used to initialize objects.\n\nThe constructor is called when an object of a class is created.\n\nIt can be used to set initial values for object attributes:\n\nCreate a constructor:\n\nTry it Yourself »\n\nNote that the constructor name must match the class name, and it cannot have a return type (like void).\n\nAlso note that the constructor is called when the object is created.\n\nAll classes have constructors by default: if you do not create a class constructor yourself, Java creates one for you. However, then you are not able to set initial values for object attributes.\n\nConstructors can also take parameters, which is used to initialize attributes.\n\nThe following example adds an int y parameter to the constructor. Inside the constructor we set x to y (x=y). When we call the constructor, we pass a parameter to the constructor (5), which will set the value of x to 5:\n\nTry it Yourself »\n\nYou can have as many parameters as you want:\n\nTry it Yourself »\n\n// Create a Main class\npublic class Main {\n  int x;  // Create a class attribute\n\n  // Create a class constructor for the Main class\n  public Main() {\n    x = 5;  // Set the initial value for the class attribute x\n  }\n\n  public static void main(String[] args) {\n    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)\n    System.out.println(myObj.x); // Print the value of x\n  }\n}\n\n// Outputs 5\n\npublic class Main {\n  int x;\n\n  public Main(int y) {\n    x = y;\n  }\n\n  public static void main(String[] args) {\n    Main myObj = new Main(5);\n    System.out.println(myObj.x);\n  }\n}\n\n// Outputs 5\n\npublic class Main {\n  int modelYear;\n  String modelName;\n\n  public Main(int year, String name) {\n    modelYear = year;\n    modelName = name;\n  }\n\n  public static void main(String[] args) {\n    Main myCar = new Main(1969, \"Mustang\");\n    System.out.println(myCar.modelYear + \" \" + myCar.modelName);\n  }\n}\n\n// Outputs 1969 Mustang\n\n// Create a Main class\npublic class Main {\n  int x;  // Create a class attribute\n\n  // Create a class constructor for the Main class\n  public Main() {\n    x = 5;  // Set the initial value for the class attribute x\n  }\n\n  public static void main(String[] args) {\n    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)\n    System.out.println(myObj.x); // Print the value of x\n  }\n}\n\n// Outputs 5\n\nvoid\nint y\npublic class Main {\n  int x;\n\n  public Main(int y) {\n    x = y;\n  }\n\n  public static void main(String[] args) {\n    Main myObj = new Main(5);\n    System.out.println(myObj.x);\n  }\n}\n\n// Outputs 5\n\npublic class Main {\n  int modelYear;\n  String modelName;\n\n  public Main(int year, String name) {\n    modelYear = year;\n    modelName = name;\n  }\n\n  public static void main(String[] args) {\n    Main myCar = new Main(1969, \"Mustang\");\n    System.out.println(myCar.modelYear + \" \" + myCar.modelName);\n  }\n}\n\n// Outputs 1969 Mustang\n",
  "Java this\n\nThe this keyword in Java refers to the current object in a method or constructor.\n\nThe this keyword is often used to avoid confusion when class attributes have the same name as method or constructor parameters.\n\nSometimes a constructor or method has a parameter with the same name as a class variable. When this happens, the parameter temporarily hides the class variable inside that method or constructor.\n\nTo refer to the class variable and not the parameter, you can use the this keyword:\n\nOutput:\n\nTry it Yourself »\n\nTip: Think of this.x = x; as: \"this.x (the class variable) gets the value of x (the parameter).\"\n\nWithout this, the code above x = x; would set the parameter x equal to itself, and the class variable would stay uninitialized (0).\n\nYou can also use this() to call another constructor in the same class.\n\nThis is useful when you want to provide default values or reuse initialization code instead of repeating it.\n\nOutput:\n\nTry it Yourself »\n\nNote: The call to this() must be the first statement inside the constructor.\n\npublic class Main {\n  int x;  // Class variable x\n\n  // Constructor with one parameter x\n  public Main(int x) {\n    this.x = x; // refers to the class variable x\n  }\n\n  public static void main(String[] args) {\n    // Create an object of Main and pass the value 5 to the constructor\n    Main myObj = new Main(5);\n    System.out.println(\"Value of x = \" + myObj.x);\n  }\n}\n\npublic class Main {\n  int modelYear;\n  String modelName;\n\n  // Constructor with one parameter\n  public Main(String modelName) {\n    // Call the two-parameter constructor to reuse code and set a default year    \n    this(2020, modelName);\n  }\n\n  // Constructor with two parameters\n  public Main(int modelYear, String modelName) {\n    // Use 'this' to assign values to the class variables\n    this.modelYear = modelYear;\n    this.modelName = modelName;\n  }\n\n  // Method to print car information\n  public void printInfo() {\n    System.out.println(modelYear + \" \" + modelName);\n  }\n\n  public static void main(String[] args) {\n    // Create a car with only model name (uses default year)\n    Main car1 = new Main(\"Corvette\");\n\n    // Create a car with both model year and name\n    Main car2 = new Main(1969, \"Mustang\");\n\n    car1.printInfo();\n    car2.printInfo();\n  }\n}\n\nthis\nthis\nthis\npublic class Main {\n  int x;  // Class variable x\n\n  // Constructor with one parameter x\n  public Main(int x) {\n    this.x = x; // refers to the class variable x\n  \n\n\n  public static void main(String[] args) {\n    // Create an object of Main and pass the value 5 to the constructor\n    Main myObj = new Main(5);\n    System.out.println(\"Value of x = \" + myObj.x);\n  \n\n\n\n\nValue of x = 5\nthis.x = x;\nthis.x\nx\nthis\nx = x;\nx\n0\nthis()\npublic class Main {\n  int modelYear;\n  String modelName;\n\n  // Constructor with one parameter\n  public Main(String modelName) {\n    // Call the two-parameter constructor to reuse code and set a default year    \n    this(2020, modelName);\n  }\n\n  // Constructor with two parameters\n  public Main(int modelYear, String modelName) {\n    // Use 'this' to assign values to the class variables\n    this.modelYear = modelYear;\n    this.modelName = modelName;\n  }\n\n  // Method to print car information\n  public void printInfo() {\n    System.out.println(modelYear + \" \" + modelName);\n  }\n\n  public static void main(String[] args) {\n    // Create a car with only model name (uses default year)\n    Main car1 = new Main(\"Corvette\");\n\n    // Create a car with both model year and name\n    Main car2 = new Main(1969, \"Mustang\");\n\n    car1.printInfo();\n    car2.printInfo();\n  }\n}\n\n2020 Corvette1969 Mustang\nthis()\nthis",
  "Java Modifiers\n\nBy now, you are quite familiar with the public keyword that appears in almost all of our examples:\n\nThe public keyword is an access modifier, meaning that it is used to set the access level for classes, attributes, methods and constructors.\n\nWe divide modifiers into two groups:\n\nFor classes, you can use either public or default:\n\nFor attributes, methods and constructors, you can use the one of the following:\n\nFor classes, you can use either final or abstract:\n\nFor attributes and methods, you can use the one of the following:\n\nIf you don't want the ability to override existing attribute values, declare attributes as final:\n\nTry it Yourself »\n\nA static method means that it can be accessed without creating an object of the class, unlike public:\n\nAn example to demonstrate the differences between static and public methods:\n\nTry it Yourself »\n\nAn abstract method belongs to an abstract class, and it does not have a body. The body is provided by the subclass:\n\nTry it Yourself »\n\npublic class Main\n\npublic class Main {\n  final int x = 10;\n  final double PI = 3.14;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 50; // will generate an error: cannot assign a value to a final variable\n    myObj.PI = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}\n\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[ ] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would output an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method\n  }\n}\n\n// Code from filename: Main.java\n// abstract classabstract class Main {\n  public String fname = \"John\";\n  public int age = 24;\n  public abstract void study(); // abstract method\n}\n\n// Subclass (inherit from Main)\nclass Student extends Main {\n  public int graduationYear = 2018;\n  public void study() { // the body of the abstract method is provided here\n    System.out.println(\"Studying all day long\");\n  }\n}\n// End code from filename: Main.java\n\n// Code from filename: Second.java\nclass Second {\n  public static void main(String[] args) {\n    // create an object of the Student class (which inherits attributes and methods from Main)\n    Student myObj = new Student();\n\n    System.out.println(\"Name: \" + myObj.fname);\n    System.out.println(\"Age: \" + myObj.age);\n    System.out.println(\"Graduation Year: \" + myObj.graduationYear);\n    myObj.study(); // call abstract method  }\n}\n\npublic\npublic class Main\n\npublic\npublic\npublic\npublic\nprivate\nprotected\nfinal\nabstract\nfinal\nabstract\nfinal\nstatic\nabstract\ntransient\nsynchronized\nvolatile\nfinal\npublic class Main {\n  final int x = 10;\n  final double PI = 3.14;\n\n  public static void main(String[] args) {\n    Main myObj = new Main();\n    myObj.x = 50; // will generate an error: cannot assign a value to a final variable\n    myObj.PI = 25; // will generate an error: cannot assign a value to a final variable\n    System.out.println(myObj.x);\n  }\n}\n\nstatic\npublic\nstatic\npublic\npublic class Main {\n  // Static method\n  static void myStaticMethod() {\n    System.out.println(\"Static methods can be called without creating objects\");\n  }\n\n  // Public method\n  public void myPublicMethod() {\n    System.out.println(\"Public methods must be called by creating objects\");\n  }\n\n  // Main method\n  public static void main(String[ ] args) {\n    myStaticMethod(); // Call the static method\n    // myPublicMethod(); This would output an error\n\n    Main myObj = new Main(); // Create an object of Main\n    myObj.myPublicMethod(); // Call the public method\n  }\n}\n\nabstract\nabstract\n// Code from filename: Main.java\n// abstract classabstract class Main {\n  public String fname = \"John\";\n  public int age = 24;\n  public abstract void study(); // abstract method\n}\n\n// Subclass (inherit from Main)\nclass Student extends Main {\n  public int graduationYear = 2018;\n  public void study() { // the body of the abstract method is provided here\n    System.out.println(\"Studying all day long\");\n  }\n}\n// End code from filename: Main.java\n\n// Code from filename: Second.java\nclass Second {\n  public static void main(String[] args) {\n    // create an object of the Student class (which inherits attributes and methods from Main)\n    Student myObj = new Student();\n\n    System.out.println(\"Name: \" + myObj.fname);\n    System.out.println(\"Age: \" + myObj.age);\n    System.out.println(\"Graduation Year: \" + myObj.graduationYear);\n    myObj.study(); // call abstract method  }\n}\n",
  "Java Encapsulation\n\nThe meaning of Encapsulation, is to make sure that \"sensitive\" data is hidden from users. To achieve this, you must: declare class variables/attributes as private provide public get and set methods to access and update the value of a private variable Get and Set You learned from the previous chapter that private variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods. The get method returns the variable value, and the set method sets the value. Syntax for both is that they start with either get or set, followed by the name of the variable, with the first letter in upper case: Example public class Person { private String name; // private = restricted access // Getter public String getName() { return name; } // Setter public void setName(String newName) { this.name = newName; } } Example explained The get method returns the value of the variable name. The set method takes a parameter (newName) and assigns it to the name variable. The this keyword is used to refer to the current object. However, as the name variable is declared as private, we cannot access it from outside this class: Example public class Main { public static void main(String[] args) { Person myObj = new Person(); myObj.name = \"John\"; // error System.out.println(myObj.name); // error } } Run Example » If the variable was declared as public, we would expect the following output: John However, as we try to access a private variable, we get an error: MyClass.java:4: error: name has private access in Person myObj.name = \"John\"; ^ MyClass.java:5: error: name has private access in Person System.out.println(myObj.name); ^ 2 errors Instead, we use the getName() and setName() methods to access and update the variable: Example public class Main { public static void main(String[] args) { Person myObj = new Person(); myObj.setName(\"John\"); // Set the value of the name variable to \"John\" System.out.println(myObj.getName()); } } // Outputs \"John\" Try it Yourself » Why Encapsulation? Better control of class attributes and methods Class attributes can be made read-only (if you only use the get method), or write-only (if you only use the set method) Flexible: the programmer can change one part of the code without affecting other parts Increased security of data ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nYou learned from the previous chapter that private variables can only be accessed within the same class (an outside class has no access to it). However, it is possible to access them if we provide public get and set methods.\n\nThe get method returns the variable value, and the set method sets the value.\n\nSyntax for both is that they start with either get or set, followed by the name of the variable, with the first letter in upper case:\n\nThe get method returns the value of the variable name.\n\nThe set method takes a parameter (newName) and assigns it to the name variable. The this keyword is used to refer to the current object.\n\nHowever, as the name variable is declared as private, we cannot access it from outside this class:\n\nRun Example »\n\nIf the variable was declared as public, we would expect the following output:\n\nHowever, as we try to access a private variable, we get an error:\n\nInstead, we use the getName() and setName() methods to access and update the variable:\n\nTry it Yourself »\n\npublic class Person {\n  private String name; // private = restricted access\n\n  // Getter\n  public String getName() {\n    return name;\n  }\n\n  // Setter\n  public void setName(String newName) {\n    this.name = newName;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.name = \"John\";  // error\n    System.out.println(myObj.name); // error \n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.setName(\"John\"); // Set the value of the name variable to \"John\"\n    System.out.println(myObj.getName());\n  }\n}\n\n// Outputs \"John\"\n\nprivate\nprivate\nprivate\nget\nset\nget\nset\npublic class Person {\n  private String name; // private = restricted access\n\n  // Getter\n  public String getName() {\n    return name;\n  }\n\n  // Setter\n  public void setName(String newName) {\n    this.name = newName;\n  }\n}\n\nget\nname\nset\nnewName\nname\nthis\nname\nprivate\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.name = \"John\";  // error\n    System.out.println(myObj.name); // error \n  }\n}\n\npublic\n\nJohn\n\nprivate\n\nMyClass.java:4: error: name has private access in Person\n    myObj.name = \"John\";\n         ^\nMyClass.java:5: error: name has private access in Person\n    System.out.println(myObj.name);\n                  ^\n2 errors\n\ngetName()\nsetName()\npublic class Main {\n  public static void main(String[] args) {\n    Person myObj = new Person();\n    myObj.setName(\"John\"); // Set the value of the name variable to \"John\"\n    System.out.println(myObj.getName());\n  }\n}\n\n// Outputs \"John\"\n\nget\nset",
  "Java Packages\n\nA package in Java is used to group related classes. Think of it as a folder in a file directory. We use packages to avoid name conflicts, and to write a better maintainable code. Packages are divided into two categories:\n\nThe Java API is a library of prewritten classes, that are free to use, included in the Java Development Environment.\n\nThe library contains components for managing input, database programming, and much much more. The complete list can be found at Oracles website: https://docs.oracle.com/javase/8/docs/api/.\n\nThe library is divided into packages and classes. Meaning you can either import a single class (along with its methods and attributes), or a whole package that contain all the classes that belong to the specified package.\n\nTo use a class or a package from the library, you need to use the import keyword:\n\nIf you find a class you want to use, for example, the Scanner class, which is used to get user input, write the following code:\n\nIn the example above, java.util is a package, while Scanner is a class of the java.util package.\n\nTo use the Scanner class, create an object of the class and use any of the available methods found in the Scanner class documentation. In our example, we will use the nextLine() method, which is used to read a complete line:\n\nUsing the Scanner class to get user input:\n\nRun Example »\n\nThere are many packages to choose from. In the previous example, we used the Scanner class from the java.util package. This package also contains date and time facilities, random-number generator and other utility classes.\n\nTo import a whole package, end the sentence with an asterisk sign (*). The following example will import ALL the classes in the java.util package:\n\nRun Example »\n\nTo create your own package, you need to understand that Java uses a file system directory to store them. Just like folders on your computer:\n\nTo create a package, use the package keyword:\n\nRun Example »\n\nSave the file as MyPackageClass.java, and compile it:\n\nThen compile the package:\n\nThis forces the compiler to create the \"mypack\" package.\n\nThe -d keyword specifies the destination for where to save the class file. You can use any directory name, like c:/user (windows), or, if you want to keep the package within the same directory, you can use the dot sign \".\", like in the example above.\n\nNote: The package name should be written in lower case to avoid conflict with class names.\n\nWhen we compiled the package in the example above, a new folder was created, called \"mypack\".\n\nTo run the MyPackageClass.java file, write the following:\n\nThe output will be:\n\nimport package.name.Class;   // Import a single class\nimport package.name.*;   // Import the whole package\n\nimport java.util.Scanner;\n\nimport java.util.Scanner;\n\nclass MyClass {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();\n    System.out.println(\"Username is: \" + userName);\n  }\n}\n\nimport java.util.*;\n\n\n└── root\n  └── mypack\n    └── MyPackageClass.java\n\npackage mypack;\nclass MyPackageClass {\n  public static void main(String[] args) {\n    System.out.println(\"This is my package!\");\n  }\n}\n\nimport\nimport package.name.Class;   // Import a single class\nimport package.name.*;   // Import the whole package\n\nScanner\nimport java.util.Scanner;\n\njava.util\nScanner\njava.util\nScanner\nScanner\nnextLine()\nScanner\nimport java.util.Scanner;\n\nclass MyClass {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();\n    System.out.println(\"Username is: \" + userName);\n  }\n}\n\nScanner\njava.util\n*\njava.util\nimport java.util.*;\n\npackage\npackage mypack;\nclass MyPackageClass {\n  public static void main(String[] args) {\n    System.out.println(\"This is my package!\");\n  }\n}\n\n-d\n.\n\nThis is my package!\n\nExemple:\n\nC:\\Users\\Your Name>javac MyPackageClass.java\n\nExemple:\n\nC:\\Users\\Your Name>javac -d . MyPackageClass.java\nExemple:\n\nC:\\Users\\Your Name>java mypack.MyPackageClass\n",
  "Java Inheritance\n\nIn Java, it is possible to inherit attributes and methods from one class to another. We group the \"inheritance concept\" into two categories:\n\nTo inherit from a class, use the extends keyword.\n\nIn the example below, the Car class (subclass) inherits the attributes and methods from the Vehicle class (superclass):\n\nTry it Yourself »\n\nDid you notice the protected modifier in Vehicle?\n\nWe set the brand attribute in Vehicle to a protected access modifier. If it was set to private, the Car class would not be able to access it.\n\n- It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class.\n\nTip: Also take a look at the next chapter, Polymorphism, which uses inherited methods to perform different tasks.\n\nIf you don't want other classes to inherit from a class, use the final keyword:\n\nIf you try to access a final class, Java will generate an error:\n\nThe output will be something like this:\n\nclass Vehicle {\n  protected String brand = \"Ford\";        // Vehicle attribute\n  public void honk() {                    // Vehicle method\n    System.out.println(\"Tuut, tuut!\");\n  }\n}\n\nclass Car extends Vehicle {\n  private String modelName = \"Mustang\";    // Car attribute\n  public static void main(String[] args) {\n\n    // Create a myCar object\n    Car myCar = new Car();\n\n    // Call the honk() method (from the Vehicle class) on the myCar object\n    myCar.honk();\n\n    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class\n    System.out.println(myCar.brand + \" \" + myCar.modelName);\n  }\n}\n\nfinal class Vehicle {\n  ...\n}\n\nclass Car extends Vehicle {\n  ...\n}\n\nextends\nCar\nVehicle\nclass Vehicle {\n  protected String brand = \"Ford\";        // Vehicle attribute\n  public void honk() {                    // Vehicle method\n    System.out.println(\"Tuut, tuut!\");\n  }\n}\n\nclass Car extends Vehicle {\n  private String modelName = \"Mustang\";    // Car attribute\n  public static void main(String[] args) {\n\n    // Create a myCar object\n    Car myCar = new Car();\n\n    // Call the honk() method (from the Vehicle class) on the myCar object\n    myCar.honk();\n\n    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class\n    System.out.println(myCar.brand + \" \" + myCar.modelName);\n  }\n}\n\nprotected\nprotected\nprivate\nfinal\nfinal\nfinal class Vehicle {\n  ...\n}\n\nclass Car extends Vehicle {\n  ...\n}\n\n\n  Main.java:9: error: cannot inherit from final Vehicleclass Main extends \n  Vehicle {\n                    ^\n  1 error)\n",
  "Java Polymorphism\n\nPolymorphism means \"many forms\", and it occurs when we have many classes that are related to each other by inheritance.\n\nLike we specified in the previous chapter; Inheritance lets us inherit attributes and methods from another class. Polymorphism uses those methods to perform different tasks. This allows us to perform a single action in different ways.\n\nFor example, think of a superclass called Animal that has a method called animalSound(). Subclasses of Animals could be Pigs, Cats, Dogs, Birds - And they also have their own implementation of an animal sound (the pig oinks, and the cat meows, etc.):\n\nRemember from the Inheritance chapter that we use the extends keyword to inherit from a class.\n\nNow we can create Pig and Dog objects and call the animalSound() method on both of them:\n\nTry it Yourself »\n\n- It is useful for code reusability: reuse attributes and methods of an existing class when you create a new class.\n\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Animal myAnimal = new Animal();  // Create a Animal object\n    Animal myPig = new Pig();  // Create a Pig object\n    Animal myDog = new Dog();  // Create a Dog object\n    myAnimal.animalSound();\n    myPig.animalSound();\n    myDog.animalSound();\n  }\n}\n\nAnimal\nanimalSound()\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\nextends\nPig\n\nDog\nanimalSound()\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Pig extends Animal {\n  public void animalSound() {\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Animal myAnimal = new Animal();  // Create a Animal object\n    Animal myPig = new Pig();  // Create a Pig object\n    Animal myDog = new Dog();  // Create a Dog object\n    myAnimal.animalSound();\n    myPig.animalSound();\n    myDog.animalSound();\n  }\n}\n",
  "Java super\n\nIn Java, the super keyword is used to refer to the parent class of a subclass.\n\nThe most common use of the super keyword is to eliminate the confusion between superclasses and subclasses that have methods with the same name.\n\nIt can be used in two main ways:\n\nIf a subclass has a method with the same name as one in its parent class, you can use super to call the parent version:\n\nOutput:\n\nTry it Yourself »\n\nNote: Use super when you want to call a method from the parent class that has been overridden in the child class.\n\nYou can also use super to access an attribute from the parent class if they have an attribute with the same name:\n\nOutput:\n\nTry it Yourself »\n\nUse super() to call the constructor of the parent class. This is especially useful for reusing initialization code.\n\nOutput:\n\nTry it Yourself »\n\nNote: The call to super() must be the first statement in the subclass constructor.\n\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    super.animalSound(); // Call the parent method\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.animalSound();\n  }\n}\n\nclass Animal {\n  String type = \"Animal\";\n}\n\nclass Dog extends Animal {\n  String type = \"Dog\";\n\n  public void printType() {\n    System.out.println(super.type); // Access parent attribute\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.printType();\n  }\n}\n\nclass Animal {\n  Animal() {\n    System.out.println(\"Animal is created\");\n  }\n}\n\nclass Dog extends Animal {\n  Dog() {\n    super(); // Call parent constructor\n    System.out.println(\"Dog is created\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n  }\n}\n\nsuper\nsuper\nsuper\nclass Animal {\n  public void animalSound() {\n    System.out.println(\"The animal makes a sound\");\n  }\n}\n\nclass Dog extends Animal {\n  public void animalSound() {\n    super.animalSound(); // Call the parent method\n    System.out.println(\"The dog says: bow wow\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.animalSound();\n  }\n}\n\nThe animal makes a soundThe dog says: bow wow\nsuper\nsuper\nclass Animal {\n  String type = \"Animal\";\n}\n\nclass Dog extends Animal {\n  String type = \"Dog\";\n\n  public void printType() {\n    System.out.println(super.type); // Access parent attribute\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n    myDog.printType();\n  }\n}\n\nAnimal\nsuper()\nclass Animal {\n  Animal() {\n    System.out.println(\"Animal is created\");\n  }\n}\n\nclass Dog extends Animal {\n  Dog() {\n    super(); // Call parent constructor\n    System.out.println(\"Dog is created\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Dog myDog = new Dog();\n  }\n}\n\nAnimal is createdDog is created\nsuper()",
  "Java Inner Classes\n\nIn Java, it is also possible to nest classes (a class within a class). The purpose of nested classes is to group classes that belong together, which makes your code more readable and maintainable.\n\nTo access the inner class, create an object of the outer class, and then create an object of the inner class:\n\nTry it Yourself »\n\nUnlike a \"regular\" class, an inner class can be private or protected. If you don't want outside objects to access the inner class, declare the class as private:\n\nIf you try to access a private inner class from an outside class, an error occurs:\n\nTry it Yourself »\n\nAn inner class can also be static, which means that you can access it without creating an object of the outer class:\n\nTry it Yourself »\n\nNote: just like static attributes and methods, a static inner class does not have access to members of the outer class.\n\nOne advantage of inner classes, is that they can access attributes and methods of the outer class:\n\nTry it Yourself »\n\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\n// Outputs 15 (5 + 10)\n\nclass OuterClass {\n  int x = 10;\n\n  private class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\nclass OuterClass {\n  int x = 10;\n\n  static class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass.InnerClass myInner = new OuterClass.InnerClass();\n    System.out.println(myInner.y);\n  }\n}\n\n// Outputs 5\n\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    public int myInnerMethod() {\n      return x;\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.myInnerMethod());\n  }\n}\n\n// Outputs 10\n\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\n// Outputs 15 (5 + 10)\n\nprivate\nprotected\nprivate\nclass OuterClass {\n  int x = 10;\n\n  private class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.y + myOuter.x);\n  }\n}\n\n\n  Main.java:13: error: OuterClass.InnerClass has private access in OuterClass\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n              ^\n\nstatic\nclass OuterClass {\n  int x = 10;\n\n  static class InnerClass {\n    int y = 5;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass.InnerClass myInner = new OuterClass.InnerClass();\n    System.out.println(myInner.y);\n  }\n}\n\n// Outputs 5\n\nstatic\nstatic\nclass OuterClass {\n  int x = 10;\n\n  class InnerClass {\n    public int myInnerMethod() {\n      return x;\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    OuterClass myOuter = new OuterClass();\n    OuterClass.InnerClass myInner = myOuter.new InnerClass();\n    System.out.println(myInner.myInnerMethod());\n  }\n}\n\n// Outputs 10\n",
  "Java Abstraction\n\nData abstraction is the process of hiding certain details and showing only essential information to the user. Abstraction can be achieved with either abstract classes or interfaces (which you will learn more about in the next chapter).\n\nThe abstract keyword is a non-access modifier, used for classes and methods: Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class). Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from). An abstract class can have both abstract and regular methods: abstract class Animal { public abstract void animalSound(); public void sleep() { System.out.println(\"Zzz\"); } } From the example above, it is not possible to create an object of the Animal class: Animal myObj = new Animal(); // will generate an error To access the abstract class, it must be inherited from another class. Let's convert the Animal class we used in the Polymorphism chapter to an abstract class: Remember from the Inheritance chapter that we use the extends keyword to inherit from a class. Example // Abstract class abstract class Animal { // Abstract method (does not have a body) public abstract void animalSound(); // Regular method public void sleep() { System.out.println(\"Zzz\"); } } // Subclass (inherit from Animal) class Pig extends Animal { public void animalSound() { // The body of animalSound() is provided here System.out.println(\"The pig says: wee wee\"); } } class Main { public static void main(String[] args) { Pig myPig = new Pig(); // Create a Pig object myPig.animalSound(); myPig.sleep(); } } Try it Yourself » Why And When To Use Abstract Classes and Methods? To achieve security - hide certain details and only show the important details of an object. Note: Abstraction can also be achieved with Interfaces, which you will learn more about in the next chapter. ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nAn abstract class can have both abstract and regular methods:\n\nFrom the example above, it is not possible to create an object of the Animal class:\n\nTo access the abstract class, it must be inherited from another class. Let's convert the Animal class we used in the Polymorphism chapter to an abstract class:\n\nRemember from the Inheritance chapter that we use the extends keyword to inherit from a class.\n\nTry it Yourself »\n\nTo achieve security - hide certain details and only show the important details of an object.\n\nNote: Abstraction can also be achieved with Interfaces, which you will learn more about in the next chapter.\n\nabstract class Animal {\n  public abstract void animalSound();\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\nAnimal myObj = new Animal(); // will generate an error\n\n// Abstract class\nabstract class Animal {\n  // Abstract method (does not have a body)\n  public abstract void animalSound();\n  // Regular method\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\n// Subclass (inherit from Animal)\nclass Pig extends Animal {\n  public void animalSound() {\n    // The body of animalSound() is provided here\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Pig myPig = new Pig(); // Create a Pig object\n    myPig.animalSound();\n    myPig.sleep();\n  }\n}\n\nabstract\nabstract class Animal {\n  public abstract void animalSound();\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\nAnimal myObj = new Animal(); // will generate an error\n\nextends\n// Abstract class\nabstract class Animal {\n  // Abstract method (does not have a body)\n  public abstract void animalSound();\n  // Regular method\n  public void sleep() {\n    System.out.println(\"Zzz\");\n  }\n}\n\n// Subclass (inherit from Animal)\nclass Pig extends Animal {\n  public void animalSound() {\n    // The body of animalSound() is provided here\n    System.out.println(\"The pig says: wee wee\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Pig myPig = new Pig(); // Create a Pig object\n    myPig.animalSound();\n    myPig.sleep();\n  }\n}\n",
  "Java Interface\n\nAnother way to achieve abstraction in Java, is with interfaces.\n\nAn interface is a completely \"abstract class\" that is used to group related methods with empty bodies:\n\nTo access the interface methods, the interface must be \"implemented\" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the \"implement\" class:\n\nTry it Yourself »\n\n1) To achieve security - hide certain details and only show the important details of an object (interface).\n\n2) Java does not support \"multiple inheritance\" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma (see example below).\n\nTo implement multiple interfaces, separate them with a comma:\n\nTry it Yourself »\n\n// interface\ninterface Animal {\n  public void animalSound(); // interface method (does not have a body)\n  public void run(); // interface method (does not have a body)\n}\n\n// Interface\ninterface Animal {\n  public void animalSound(); // interface method (does not have a body)\n  public void sleep(); // interface method (does not have a body)\n}\n\n// Pig \"implements\" the Animal interface\nclass Pig implements Animal {\n  public void animalSound() {\n    // The body of animalSound() is provided here\n    System.out.println(\"The pig says: wee wee\");\n  }\n  public void sleep() {\n    // The body of sleep() is provided here\n    System.out.println(\"Zzz\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Pig myPig = new Pig();  // Create a Pig object\n    myPig.animalSound();\n    myPig.sleep();\n  }\n}\n\ninterface FirstInterface {\n  public void myMethod(); // interface method\n}\n\ninterface SecondInterface {\n  public void myOtherMethod(); // interface method\n}\n\nclass DemoClass implements FirstInterface, SecondInterface {\n  public void myMethod() {\n    System.out.println(\"Some text..\");\n  }\n  public void myOtherMethod() {\n    System.out.println(\"Some other text...\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    DemoClass myObj = new DemoClass();\n    myObj.myMethod();\n    myObj.myOtherMethod();\n  }\n}\n\ninterface\n// interface\ninterface Animal {\n  public void animalSound(); // interface method (does not have a body)\n  public void run(); // interface method (does not have a body)\n}\n\nimplements\nextends\n// Interface\ninterface Animal {\n  public void animalSound(); // interface method (does not have a body)\n  public void sleep(); // interface method (does not have a body)\n}\n\n// Pig \"implements\" the Animal interface\nclass Pig implements Animal {\n  public void animalSound() {\n    // The body of animalSound() is provided here\n    System.out.println(\"The pig says: wee wee\");\n  }\n  public void sleep() {\n    // The body of sleep() is provided here\n    System.out.println(\"Zzz\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    Pig myPig = new Pig();  // Create a Pig object\n    myPig.animalSound();\n    myPig.sleep();\n  }\n}\n\nabstract\npublic\npublic\nstatic\nfinal\ninterface FirstInterface {\n  public void myMethod(); // interface method\n}\n\ninterface SecondInterface {\n  public void myOtherMethod(); // interface method\n}\n\nclass DemoClass implements FirstInterface, SecondInterface {\n  public void myMethod() {\n    System.out.println(\"Some text..\");\n  }\n  public void myOtherMethod() {\n    System.out.println(\"Some other text...\");\n  }\n}\n\nclass Main {\n  public static void main(String[] args) {\n    DemoClass myObj = new DemoClass();\n    myObj.myMethod();\n    myObj.myOtherMethod();\n  }\n}\n",
  "Java Enums\n\nAn enum is a special \"class\" that represents a group of constants (unchangeable variables, like final variables).\n\nTo create an enum, use the enum keyword (instead of class or interface), and separate the constants with a comma. Note that they should be in uppercase letters:\n\nYou can access enum constants with the dot syntax:\n\nEnum is short for \"enumerations\", which means \"specifically listed\".\n\nYou can also have an enum inside a class:\n\nThe output will be:\n\nEnums are often used in switch statements to check for corresponding values:\n\nThe output will be:\n\nThe enum type has a values() method, which returns an array of all enum constants. This method is useful when you want to loop through the constants of an enum:\n\nThe output will be:\n\nAn enum can, just like a class, have attributes and methods. The only difference is that enum constants are public, static and final (unchangeable - cannot be overridden).\n\nAn enum cannot be used to create objects, and it cannot extend other classes (but it can implement interfaces).\n\nUse enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.\n\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main {\n  enum Level {\n    LOW,\n    MEDIUM,\n    HIGH\n  }\n\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM; \n    System.out.println(myVar);\n  }\n}\n\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM;\n\n    switch(myVar) {\n      case LOW:\n        System.out.println(\"Low level\");\n        break;\n      case MEDIUM:\n         System.out.println(\"Medium level\");\n        break;\n      case HIGH:\n        System.out.println(\"High level\");\n        break;\n    }\n  }\n}\n\nfor (Level myVar : Level.values()) {\n  System.out.println(myVar);\n}\n\nenum\nfinal\nenum\nenum\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\nenum\nenum\npublic class Main {\n  enum Level {\n    LOW,\n    MEDIUM,\n    HIGH\n  }\n\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM; \n    System.out.println(myVar);\n  }\n}\n\n\nMEDIUM\n\nswitch\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Level myVar = Level.MEDIUM;\n\n    switch(myVar) {\n      case LOW:\n        System.out.println(\"Low level\");\n        break;\n      case MEDIUM:\n         System.out.println(\"Medium level\");\n        break;\n      case HIGH:\n        System.out.println(\"High level\");\n        break;\n    }\n  }\n}\n\n\nMedium level\n\nvalues()\nfor (Level myVar : Level.values()) {\n  System.out.println(myVar);\n}\n\n\nLOW\nMEDIUM\nHIGH\nenum\nclass\npublic\nstatic\nfinal\nenum\nExample:\n\n  Level myVar = Level.MEDIUM;",
  "Java User Input (Scanner)\n\nThe Scanner class is used to get user input, and it is found in the java.util package.\n\nTo use the Scanner class, create an object of the class and use any of the available methods found in the Scanner class documentation. In our example, we will use the nextLine() method, which is used to read Strings:\n\nRun Example »\n\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nIn the example above, we used the nextLine() method, which is used to read Strings. To read other types, look at the table below:\n\nIn the example below, we use different methods to read data of various types:\n\nRun Example »\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\").\n\nYou can read more about exceptions and how to handle errors in the Exceptions chapter.\n\nTip: For a complete reference of Scanner methods, go to our Java Scanner Reference.\n\nimport java.util.Scanner;  // Import the Scanner class\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);  // Create a Scanner object\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();  // Read user input\n    System.out.println(\"Username is: \" + userName);  // Output user input\n  }\n}\n\nimport java.util.Scanner;\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n\n    System.out.println(\"Enter name, age and salary:\");\n\n    // String input\n    String name = myObj.nextLine();\n\n    // Numerical input\n    int age = myObj.nextInt();\n    double salary = myObj.nextDouble();\n\n    // Output input by user\n    System.out.println(\"Name: \" + name);\n    System.out.println(\"Age: \" + age);\n    System.out.println(\"Salary: \" + salary);\n  }\n}\n\nScanner\njava.util\nScanner\nScanner\nnextLine()\nimport java.util.Scanner;  // Import the Scanner class\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);  // Create a Scanner object\n    System.out.println(\"Enter username\");\n\n    String userName = myObj.nextLine();  // Read user input\n    System.out.println(\"Username is: \" + userName);  // Output user input\n  }\n}\n\nnextLine()\nnextBoolean()\nboolean\nnextByte()\nbyte\nnextDouble()\ndouble\nnextFloat()\nfloat\nnextInt()\nint\nnextLine()\nString\nnextLong()\nlong\nnextShort()\nshort\nimport java.util.Scanner;\n\nclass Main {\n  public static void main(String[] args) {\n    Scanner myObj = new Scanner(System.in);\n\n    System.out.println(\"Enter name, age and salary:\");\n\n    // String input\n    String name = myObj.nextLine();\n\n    // Numerical input\n    int age = myObj.nextInt();\n    double salary = myObj.nextDouble();\n\n    // Output input by user\n    System.out.println(\"Name: \" + name);\n    System.out.println(\"Age: \" + age);\n    System.out.println(\"Salary: \" + salary);\n  }\n}\n",
  "Java Date and Time\n\nJava does not have a built-in Date class, but we can import the java.time package to work with the date and time API. The package includes many date and time classes. For example:\n\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nTo display the current date, import the java.time.LocalDate class, and use its now() method:\n\nThe output will be:\n\nTo display the current time (hour, minute, second, and nanoseconds), import the java.time.LocalTime class, and use its now() method:\n\nThis example displays the server's local time, which may differ from your local time:\n\nTo display the current date and time, import the java.time.LocalDateTime class, and use its now() method:\n\nThe output will be something like this:\n\nThe \"T\" in the example above is used to separate the date from the time. You can use the DateTimeFormatter class with the ofPattern() method in the same package to format or parse date-time objects. The following example will remove both the \"T\" and nanoseconds from the date-time:\n\nThe output will be:\n\nThe ofPattern() method accepts all sorts of values, if you want to display the date and time in a different format. For example:\n\nimport java.time.LocalDate; // import the LocalDate class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDate myObj = LocalDate.now(); // Create a date object\n    System.out.println(myObj); // Display the current date\n  }\n}\n\nimport java.time.LocalTime; // import the LocalTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalTime myObj = LocalTime.now();\n    System.out.println(myObj);\n  }\n}\n\nimport java.time.LocalDateTime; // import the LocalDateTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myObj = LocalDateTime.now();\n    System.out.println(myObj);\n  }\n}\n\nimport java.time.LocalDateTime; // Import the LocalDateTime class\nimport java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myDateObj = LocalDateTime.now();\n    System.out.println(\"Before formatting: \" + myDateObj);\n    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\n    String formattedDate = myDateObj.format(myFormatObj);\n    System.out.println(\"After formatting: \" + formattedDate);\n  }\n}\n\njava.time\nLocalDate\nLocalTime\nLocalDateTime\nDateTimeFormatter\njava.time.LocalDate\nnow()\nimport java.time.LocalDate; // import the LocalDate class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDate myObj = LocalDate.now(); // Create a date object\n    System.out.println(myObj); // Display the current date\n  }\n}\n\n\n\n\njava.time.LocalTime\nnow()\nimport java.time.LocalTime; // import the LocalTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalTime myObj = LocalTime.now();\n    System.out.println(myObj);\n  }\n}\n\n\n\n\njava.time.LocalDateTime\nnow()\nimport java.time.LocalDateTime; // import the LocalDateTime class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myObj = LocalDateTime.now();\n    System.out.println(myObj);\n  }\n}\n\n\n\n\nDateTimeFormatter\nofPattern()\nimport java.time.LocalDateTime; // Import the LocalDateTime class\nimport java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class\n\npublic class Main {\n  public static void main(String[] args) {\n    LocalDateTime myDateObj = LocalDateTime.now();\n    System.out.println(\"Before formatting: \" + myDateObj);\n    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern(\"dd-MM-yyyy HH:mm:ss\");\n\n    String formattedDate = myDateObj.format(myFormatObj);\n    System.out.println(\"After formatting: \" + formattedDate);\n  }\n}\n\n\n\n\n\n\nofPattern()",
  "Java Errors\n\nEven experienced Java developers make mistakes. The key is learning how to spot and fix them!\n\nThese pages cover common errors and helpful debugging tips to help you understand what's going wrong and how to fix it.\n\nCompile-time errors occur when the program cannot compile due to syntax or type issues.\n\nHere are some examples:\n\n1) Missing Semicolon\n\nResult:\n\nTry it Yourself »\n\nTip: Java requires a semicolon at the end of every statement (int x = 5;).\n\n2) Undeclared Variables\n\nResult:\n\nTry it Yourself »\n\nTip: You must declare a variable before using it (int myVar = 50;).\n\n3) Mismatched Types\n\nResult:\n\nTry it Yourself »\n\nTip: Make sure the value matches the variable type (String x = \"Hello\";).\n\nRuntime errors occur when the program compiles but crashes or behaves unexpectedly.\n\nHere are some examples:\n\n1) Division by Zero\n\nResult:\n\nTry it Yourself »\n\n2) Array Index Out of Bounds\n\nResult:\n\nTry it Yourself »\n\nLogical errors happen when the code runs, but the result is not what you thought:\n\nResult:\n\nTry it Yourself »\n\nExpected Result: 12\n\nLogical Error: The code mistakenly subtracts instead of adds.\n\nTip: Test your program with different inputs to catch logic flaws (try using x + y instead). This is part of debugging, which you will learn more about in the next chapter.\n\nIn the next chapter, you will learn how to debug your code - how to find and fix bugs/errors in your program.\n\nint x = 5\nSystem.out.println(x);\n\nSystem.out.println(myVar);\n\nint x = \"Hello\";\n\nint x = 10;\nint y = 0;\nint result = x / y;\nSystem.out.println(result);\n\nint[] numbers = {1, 2, 3};\nSystem.out.println(numbers[8]);\n\nint x = 10;\nint y = 2;\nint sum = x - y;\nSystem.out.println(\"x + y = \" + sum);\nint x = 5\nSystem.out.println(x);\n\nerror: ';' expected\nint x = 5;\nSystem.out.println(myVar);\n\n\ncannot find symbol\n  symbol:   variable myVar\n\nint myVar = 50;\nint x = \"Hello\";\n\n\nincompatible types: String cannot be converted to int\n\nString x = \"Hello\";\nint x = 10;\nint y = 0;\nint result = x / y;\nSystem.out.println(result);\n\n\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n\nint[] numbers = {1, 2, 3};\nSystem.out.println(numbers[8]);\n\n\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 3\n\nint x = 10;\nint y = 2;\nint sum = x - y;\nSystem.out.println(\"x + y = \" + sum);\n\n  x + y = 8\n\n12\nx + y",
  "Java Debugging\n\nAfter learning about common errors, the next step is understanding how to debug your Java code - that is, how to find and fix those errors effectively.\n\nThis page introduces simple debugging techniques that are useful for beginners and helpful even for experienced developers.\n\nDebugging is the process of identifying and fixing errors or bugs in your code.\n\nIt often involves:\n\nTip: Debugging is a skill that improves with practice. The more you debug, the better you get at spotting problems quickly.\n\nThe most basic (and often most effective) way to debug Java code is to use System.out.println() to print values and check the flow of the program.\n\nIn this example, the first line \"Before division\" will print, but the second line is never reached because the program crashes due to division by zero:\n\nResult:\n\nTry it Yourself »\n\nTip: Add print statements before and after key lines of code to find out where things go wrong.\n\nIf something unexpected happens, print out the values of your variables:\n\nTry it Yourself »\n\nTip: This is a good way to test whether a condition is working correctly - try changing age to 18 or 19 and observe the output!\n\nModern IDEs like IntelliJ IDEA, Eclipse, and NetBeans come with built-in debugging tools.\n\nTip: Use your IDE's debugger to find errors faster - it's more powerful than print statements alone!\n\nIn the next chapter, you will learn about how to handle errors gracefully in your programs with Java Exceptions.\n\nint x = 10;\nint y = 0;\n\nSystem.out.println(\"Before division\");  // Debug output\n\nint result = x / y;  // Crashes\n\nSystem.out.println(\"Result: \" + result);  // Never runs\n\nint age = 17;\nSystem.out.println(\"Age: \" + age);\n\nif (age >= 18) {\n  System.out.println(\"Access granted\");\n} else {\n  System.out.println(\"Access denied\");\n}\n\nSystem.out.println()\n\"Before division\"\nint x = 10;\nint y = 0;\n\nSystem.out.println(\"Before division\");  // Debug output\n\nint result = x / y;  // Crashes\n\nSystem.out.println(\"Result: \" + result);  // Never runs\n\n\nBefore division\nException in thread \"main\" java.lang.ArithmeticException: / by zero\nint age = 17;\nSystem.out.println(\"Age: \" + age);\n\nif (age >= 18) {\n  System.out.println(\"Access granted\");\n} else {\n  System.out.println(\"Access denied\");\n}\n\nage",
  "Java Exceptions - Try...Catch\n\nAs mentioned in the Errors chapter, different types of errors can occur while running a program - such as coding mistakes, invalid input, or unexpected situations.\n\nWhen an error occurs, Java will normally stop and generate an error message. The technical term for this is: Java will throw an exception (throw an error).\n\nException handling lets you catch and handle errors during runtime - so your program doesn't crash.\n\nIt uses different keywords:\n\nThe try statement allows you to define a block of code to be tested for errors while it is being executed.\n\nThe catch statement allows you to define a block of code to be executed, if an error occurs in the try block.\n\nThe try and catch keywords come in pairs:\n\nConsider the following example:\n\nThis will generate an error, because myNumbers[10] does not exist.\n\nThe output will be something like this:\n\nNote: ArrayIndexOutOfBoundsException occurs when you try to access an index number that does not exist.\n\nIf an error occurs, we can use try...catch to catch the error and execute some code to handle it:\n\nThe output will be:\n\nThe finally statement lets you execute code, after try...catch, regardless of the result:\n\nThe output will be:\n\nThe throw statement allows you to create a custom error.\n\nThe throw statement is used together with an exception type. There are many exception types available in Java: ArithmeticException, FileNotFoundException, ArrayIndexOutOfBoundsException, SecurityException, etc:\n\nThrow an exception if age is below 18 (print \"Access denied\"). If age is 18 or older, print \"Access granted\":\n\nThe output will be:\n\nIf age was 20, you would not get an exception:\n\nThe output will be:\n\nFor a list of different errors and exception types, go to our Java Errors and Exception Types Reference.\n\ntry {\n  //  Block of code to try\n}\ncatch(Exception e) {\n  //  Block of code to handle errors\n}\n\npublic class Main {\n  public static void main(String[ ] args) {\n    int[] myNumbers = {1, 2, 3};\n    System.out.println(myNumbers[10]); // error!\n  }\n}\n\npublic class Main {\n  public static void main(String[ ] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    } finally {\n      System.out.println(\"The 'try catch' is finished.\");\n    }\n  }\n}\n\npublic class Main {\n  static void checkAge(int age) {\n    if (age < 18) {\n      throw new ArithmeticException(\"Access denied - You must be at least 18 years old.\");\n    }\n    else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n  }\n\n  public static void main(String[] args) {\n    checkAge(15); // Set age to 15 (which is below 18...)\n  }\n}\n\ncheckAge(20);\n\ntry\ncatch\ntry\ncatch\ntry {\n  //  Block of code to try\n}\ncatch(Exception e) {\n  //  Block of code to handle errors\n}\n\npublic class Main {\n  public static void main(String[ ] args) {\n    int[] myNumbers = {1, 2, 3};\n    System.out.println(myNumbers[10]); // error!\n  }\n}\n\n\n  Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 10        \n  at Main.main(Main.java:4)\n\nArrayIndexOutOfBoundsException\ntry...catch\npublic class Main {\n  public static void main(String[ ] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    }\n  }\n}\n\n\nSomething went wrong.\nfinally\ntry...catch\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      int[] myNumbers = {1, 2, 3};\n      System.out.println(myNumbers[10]);\n    } catch (Exception e) {\n      System.out.println(\"Something went wrong.\");\n    } finally {\n      System.out.println(\"The 'try catch' is finished.\");\n    }\n  }\n}\n\n\nSomething went wrong.\nThe 'try catch' is finished.\n\nthrow\nthrow\nArithmeticException\nFileNotFoundException\nArrayIndexOutOfBoundsException\nSecurityException\npublic class Main {\n  static void checkAge(int age) {\n    if (age < 18) {\n      throw new ArithmeticException(\"Access denied - You must be at least 18 years old.\");\n    }\n    else {\n      System.out.println(\"Access granted - You are old enough!\");\n    }\n  }\n\n  public static void main(String[] args) {\n    checkAge(15); // Set age to 15 (which is below 18...)\n  }\n}\n\n\nException in thread \"main\" java.lang.ArithmeticException: Access denied - You must be at least 18 years old.\n        at Main.checkAge(Main.java:4)\n        at Main.main(Main.java:12)\n\ncheckAge(20);\n\n\nAccess granted - You are old enough!\n",
  "Java Files\n\nFile handling is an important part of any application.\n\nJava has several methods for creating, reading, updating, and deleting files.\n\nThe File class from the java.io package, allows us to work with files.\n\nTo use the File class, create an object of the class, and specify the filename or directory name: Example import java.io.File; // Import the File class File myObj = new File(\"filename.txt\"); // Specify the filename If you don't know what a package is, read our Java Packages Tutorial. The File class has many useful methods for creating and getting information about files. For example: Method Type Description canRead() Boolean Tests whether the file is readable or not canWrite() Boolean Tests whether the file is writable or not createNewFile() Boolean Creates an empty file delete() Boolean Deletes a file exists() Boolean Tests whether the file exists getName() String Returns the name of the file getAbsolutePath() String Returns the absolute pathname of the file length() Long Returns the size of the file in bytes list() String[] Returns an array of the files in the directory mkdir() Boolean Creates a directory You will learn how to create, write, read and delete files in the next chapters: Create/Write Files » Read Files » Delete Files » ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nIf you don't know what a package is, read our Java Packages Tutorial.\n\nThe File class has many useful methods for creating and getting information about files. For example:\n\nYou will learn how to create, write, read and delete files in the next chapters:\n\nimport java.io.File;  // Import the File class\n\nFile myObj = new File(\"filename.txt\"); // Specify the filename\n\nFile\njava.io\nFile\nimport java.io.File;  // Import the File class\n\nFile myObj = new File(\"filename.txt\"); // Specify the filename\n\nFile\ncanRead()\ncanWrite()\ncreateNewFile()\ndelete()\nexists()\ngetName()\ngetAbsolutePath()\nlength()\nlist()\nmkdir()",
  "Java Create and Write To Files\n\nTo create a file in Java, you can use the createNewFile() method. This method returns a boolean value: true if the file was successfully created, and false if the file already exists. Note that the method is enclosed in a try...catch block. This is necessary because it throws an IOException if an error occurs (if the file cannot be created for some reason):\n\nThe output will be:\n\nTo create a file in a specific directory (requires permission), specify the path of the file and use double backslashes to escape the \"\\\" character (for Windows). On Mac and Linux you can just write the path, like: /Users/name/filename.txt\n\nRun Example »\n\nIn the following example, we use the FileWriter class together with its write() method to write some text to the file we created in the example above. Note that when you are done writing to the file, you should close it with the close() method:\n\nThe output will be:\n\nTo read the file above, go to the Java Read Files chapter.\n\nimport java.io.File;  // Import the File class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class CreateFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      if (myObj.createNewFile()) {\n        System.out.println(\"File created: \" + myObj.getName());\n      } else {\n        System.out.println(\"File already exists.\");\n      }\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\nFile myObj = new File(\"C:\\\\Users\\\\MyName\\\\filename.txt\");\n\nimport java.io.FileWriter;   // Import the FileWriter class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class WriteToFile {\n  public static void main(String[] args) {\n    try {\n      FileWriter myWriter = new FileWriter(\"filename.txt\");\n      myWriter.write(\"Files in Java might be tricky, but it is fun enough!\");\n      myWriter.close();\n      System.out.println(\"Successfully wrote to the file.\");\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\ncreateNewFile()\ntrue\nfalse\ntry...catch\nIOException\nimport java.io.File;  // Import the File class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class CreateFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      if (myObj.createNewFile()) {\n        System.out.println(\"File created: \" + myObj.getName());\n      } else {\n        System.out.println(\"File already exists.\");\n      }\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\nFile created: filename.txt\n\\\nFile myObj = new File(\"C:\\\\Users\\\\MyName\\\\filename.txt\");\n\nFileWriter\nwrite()\nclose()\nimport java.io.FileWriter;   // Import the FileWriter class\nimport java.io.IOException;  // Import the IOException class to handle errors\n\npublic class WriteToFile {\n  public static void main(String[] args) {\n    try {\n      FileWriter myWriter = new FileWriter(\"filename.txt\");\n      myWriter.write(\"Files in Java might be tricky, but it is fun enough!\");\n      myWriter.close();\n      System.out.println(\"Successfully wrote to the file.\");\n    } catch (IOException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\n\nSuccessfully wrote to the file.\n",
  "Java Read Files\n\nIn the previous chapter, you learned how to create and write to a file.\n\nIn the following example, we use the Scanner class to read the contents of the text file we created in the previous chapter:\n\nThe output will be:\n\nTo get more information about a file, use any of the File methods:\n\nThe output will be:\n\nNote: There are many available classes in the Java API that can be used to read and write files in Java: FileReader, BufferedReader, Files, Scanner, FileInputStream, FileWriter, BufferedWriter, FileOutputStream, etc. Which one to use depends on the Java version you're working with and whether you need to read bytes or characters, and the size of the file/lines etc.\n\nTip: To delete a file, read our Java Delete Files chapter.\n\nimport java.io.File;  // Import the File class\nimport java.io.FileNotFoundException;  // Import this class to handle errors\nimport java.util.Scanner; // Import the Scanner class to read text files\n\npublic class ReadFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      Scanner myReader = new Scanner(myObj);\n      while (myReader.hasNextLine()) {\n        String data = myReader.nextLine();\n        System.out.println(data);\n      }\n      myReader.close();\n    } catch (FileNotFoundException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\nimport java.io.File;  // Import the File class\n\npublic class GetFileInfo {   public static void main(String[] args) {\n    File myObj = new File(\"filename.txt\");\n    if (myObj.exists()) {\n      System.out.println(\"File name: \" + myObj.getName());\n      System.out.println(\"Absolute path: \" + myObj.getAbsolutePath());\n      System.out.println(\"Writeable: \" + myObj.canWrite());\n      System.out.println(\"Readable \" + myObj.canRead());\n      System.out.println(\"File size in bytes \" + myObj.length());\n    } else {\n      System.out.println(\"The file does not exist.\");\n    }\n  }\n}\n\nScanner\nimport java.io.File;  // Import the File class\nimport java.io.FileNotFoundException;  // Import this class to handle errors\nimport java.util.Scanner; // Import the Scanner class to read text files\n\npublic class ReadFile {\n  public static void main(String[] args) {\n    try {\n      File myObj = new File(\"filename.txt\");\n      Scanner myReader = new Scanner(myObj);\n      while (myReader.hasNextLine()) {\n        String data = myReader.nextLine();\n        System.out.println(data);\n      }\n      myReader.close();\n    } catch (FileNotFoundException e) {\n      System.out.println(\"An error occurred.\");\n      e.printStackTrace();\n    }\n  }\n}\n\n\nFiles in Java might be tricky, but it is fun enough!\nFile\nimport java.io.File;  // Import the File class\n\npublic class GetFileInfo {   public static void main(String[] args) {\n    File myObj = new File(\"filename.txt\");\n    if (myObj.exists()) {\n      System.out.println(\"File name: \" + myObj.getName());\n      System.out.println(\"Absolute path: \" + myObj.getAbsolutePath());\n      System.out.println(\"Writeable: \" + myObj.canWrite());\n      System.out.println(\"Readable \" + myObj.canRead());\n      System.out.println(\"File size in bytes \" + myObj.length());\n    } else {\n      System.out.println(\"The file does not exist.\");\n    }\n  }\n}\n\n\nFile name: filename.txt\nAbsolute path: C:\\Users\\MyName\\filename.txt\nWriteable: true\nReadable: true\nFile size in bytes: 0\n\nFileReader, BufferedReader, Files, Scanner, FileInputStream, FileWriter, BufferedWriter, FileOutputStream",
  "Java Delete Files\n\nTo delete a file in Java, use the delete() method:\n\nThe output will be:\n\nYou can also delete a folder. However, it must be empty:\n\nThe output will be:\n\nimport java.io.File;  // Import the File class\n\npublic class DeleteFile {\n  public static void main(String[] args) { \n    File myObj = new File(\"filename.txt\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the file: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the file.\");\n    } \n  } \n}\nimport java.io.File; \n\npublic class DeleteFolder {\n  public static void main(String[] args) { \n    File myObj = new File(\"C:\\\\Users\\\\MyName\\\\Test\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the folder: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the folder.\");\n    } \n  } \n}\ndelete()\nimport java.io.File;  // Import the File class\n\npublic class DeleteFile {\n  public static void main(String[] args) { \n    File myObj = new File(\"filename.txt\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the file: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the file.\");\n    } \n  } \n}\n\nDeleted the file: filename.txt\n\nimport java.io.File; \n\npublic class DeleteFolder {\n  public static void main(String[] args) { \n    File myObj = new File(\"C:\\\\Users\\\\MyName\\\\Test\"); \n    if (myObj.delete()) { \n      System.out.println(\"Deleted the folder: \" + myObj.getName());\n    } else {\n      System.out.println(\"Failed to delete the folder.\");\n    } \n  } \n\n\nDeleted the folder: Test\n",
  "Java Data Structures\n\nData structures are ways to store and organize data so you can use it efficiently.\n\nAn array is an example of a data structure, which allows multiple elements to be stored in a single variable.\n\nSome of the most common are:\n\nTip: Data structures are like supercharged arrays - more flexible and feature-rich!\n\nWe'll explore all of these - and many more - in detail later, but for now, here's a quick introduction to each one.\n\nAn ArrayList is a resizable array that can grow as needed.\n\nIt allows you to store elements and access them by index.\n\nTry it Yourself »\n\nA HashSet is a collection where every element is unique - no duplicates are allowed.\n\nTry it Yourself »\n\nNote: In the example above, even though BMW is added twice it only appears once in the set because every element in a set has to be unique.\n\nA HashMap stores key-value pairs, which are great when you want to store values and find them by a key (like a name or ID):\n\nTry it Yourself »\n\nWhen learning about data structures, you will often hear about iterators too.\n\nAn iterator is a way to loop through elements in a data structure.\n\nIt is called an \"iterator\" because \"iterating\" is the technical term for looping.\n\nUsing an Iterator with ArrayList:\n\nTry it Yourself »\n\nNext, let's take a closer look at each data structure in more detail.\n\n// Import the ArrayList class\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n// Import the HashSet class\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    HashSet<String> cars = new HashSet<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a HashMap object called capitalCities\n    HashMap<String, String> capitalCities = new HashMap<String, String>();\n\n    // Add keys and values (Country, City)\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"Germany\", \"Berlin\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"USA\", \"Washington DC\");\n    System.out.println(capitalCities);\n  }\n}\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create an ArrayList of Strings\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    // Get an iterator for the ArrayList\n    Iterator<String> it = cars.iterator();\n\n    // Iterate through the list using the iterator\n    while(it.hasNext()) {\n      System.out.println(it.next());\n    }\n  }\n}\njava.util\nArrayList\nHashSet\nHashMap\nArrayList\n// Import the ArrayList class\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  \n\n\nHashSet\n// Import the HashSet class\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    HashSet<String> cars = new HashSet<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\nHashMap\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a HashMap object called capitalCities\n    HashMap<String, String> capitalCities = new HashMap<String, String>();\n\n    // Add keys and values (Country, City)\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"Germany\", \"Berlin\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"USA\", \"Washington DC\");\n    System.out.println(capitalCities);\n  }\n}\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create an ArrayList of Strings\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    // Get an iterator for the ArrayList\n    Iterator<String> it = cars.iterator();\n\n    // Iterate through the list using the iterator\n    while(it.hasNext()) {\n      System.out.println(it.next());\n    }\n  }\n}",
  "Java Collections Framework\n\nBefore we explore ArrayList, HashSet, HashMap, and other data structures in more detail, it's important to understand that all of these are part of something bigger - the Java Collections Framework.\n\nThe Java Collections Framework provides a set of interfaces (like List, Set, and Map) and a set of classes (ArrayList, HashSet, HashMap, etc.) that implement those interfaces.\n\nAll of these are part of the java.util package.\n\nThey are used to store, search, sort, and organize data more easily - all using standardized methods and patterns.\n\nTip: Think of the Collections Framework as a toolbox.\n\nInterfaces like List define what tools can do, and classes like ArrayList are the actual tools that do the work.\n\nHere are some common interfaces, along with their classes:\n\nThe table below gives an overview of the common data structure classes and their characteristics:\n\nUse List classes when you care about order, you may have duplicates, and want to access elements by index.\n\nUse Set classes when you need to store unique values only.\n\nUse Map classes when you need to store pairs of keys and values, like a name and its phone number.\n\nIn the next chapters, you will learn how to use each of these data structures in detail - how to add, remove, sort, and search elements, and choose the right structure for your task.\n\nArrayList\nHashSet\nHashMap\nList\nSet\nMap\nArrayList\nHashSet\nHashMap\njava.util\nList\nArrayList\nList\nArrayList\nLinkedList\nSet\nHashSet\nTreeSet\nLinkedHashSet\nMap\nHashMap\nTreeMap\nLinkedHashMap\nList\nArrayList\nLinkedList\nSet\nHashSet\nTreeSet\nLinkedHashSet\nMap\nHashMap\nTreeMap\nLinkedHashMap\nList\nSet\nMap",
  "Java List\n\nThe List interface is part of the Java Collections Framework and represents an ordered collection of elements.\n\nYou can access elements by their index, add duplicates, and maintain the insertion order.\n\nSince List is an interface, you cannot create a List object directly.\n\nInstead, you use a class that implements the List interface, such as:\n\nTip: Use List when you care about order, you may have duplicates, and want to access elements by index.\n\nIn the next chapters, you will learn how to use ArrayList and LinkedList.\n\nList\nList\nArrayList\nLinkedList\nList\nadd()\nget()\nset()\nremove()\nsize()\nArrayList\nLinkedList",
  "Java ArrayList\n\nAn ArrayList is like a resizable array.\n\nIt is part of the java.util package and implements the List interface.\n\nThe difference between a built-in array and an ArrayList in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an ArrayList whenever you want.\n\nTo use an ArrayList, you must first import it from java.util:\n\nCreate an ArrayList object called cars that will store strings:\n\nNow you can use methods like add(), get(), set(), and remove() to manage your list of elements.\n\nTo add elements to an ArrayList, use the add() method:\n\nTry it Yourself »\n\nYou can also add an element at a specified position by referring to the index number:\n\nTry it Yourself »\n\nAn ArrayList keeps elements in the same order you add them, so the first item you add will be at index 0, the next at index 1, and so on.\n\nTo access an element in the ArrayList, use the get() method and refer to the index number:\n\nTry it Yourself »\n\nTo modify an element, use the set() method and refer to the index number:\n\nTry it Yourself »\n\nTo remove an element, use the remove() method and refer to the index number:\n\nTry it Yourself »\n\nTo remove all the elements in the ArrayList, use the clear() method:\n\nTry it Yourself »\n\nTo find out how many elements an ArrayList have, use the size method:\n\nTry it Yourself »\n\nLoop through the elements of an ArrayList with a for loop, and use the size() method to specify how many times the loop should run:\n\nTry it Yourself »\n\nYou can also loop through an ArrayList with the for-each loop:\n\nTry it Yourself »\n\nElements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nCreate an ArrayList to store numbers (add elements of type Integer):\n\nTry it Yourself »\n\nAnother useful class in the java.util package is the Collections class, which include the sort() method for sorting lists alphabetically or numerically:\n\nSort an ArrayList of Strings:\n\nTry it Yourself »\n\nSort an ArrayList of Integers:\n\nTry it Yourself »\n\nNote: Sometimes you will see both List and ArrayList in Java code, like this:\n\nThis means the variable (cars) is declared as a List (the interface), but it stores an ArrayList object (the actual list).\n\nIt works the same way, but some developers prefer this style because it gives them more flexibility to change the type later.\n\nFor a complete reference of ArrayList methods, go to our Java ArrayList Reference.\n\nimport java.util.ArrayList; // Import the ArrayList class\n\nArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n\n    cars.add(0, \"Mazda\"); // Insert element at the beginning of the list (0)\n\n    System.out.println(cars);\n  }\n}\ncars.get(0);  // Get the first element\n\ncars.set(0, \"Opel\");\n\ncars.remove(0);\n\ncars.clear();\n\ncars.size();\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (int i = 0; i < cars.size(); i++) {\n      System.out.println(cars.get(i));\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(10);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(25);\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    Collections.sort(cars);  // Sort cars\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers);  // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.List;\nimport java.util.ArrayList;\n\nList<String> cars = new ArrayList<>();\nArrayList\njava.util\nList\nArrayList\nArrayList\nArrayList\njava.util\nArrayList\nimport java.util.ArrayList; // Import the ArrayList class\n\nArrayList<String> cars = new ArrayList<String>(); // Create an ArrayList object\nadd()\nget()\nset()\nremove()\nArrayList\nadd()\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n\n    cars.add(0, \"Mazda\"); // Insert element at the beginning of the list (0)\n\n    System.out.println(cars);\n  }\n}\nArrayList\nArrayList\nget()\ncars.get(0);  // Get the first element\n\nset()\ncars.set(0, \"Opel\");\n\nremove()\ncars.remove(0);\n\nArrayList\nclear()\ncars.clear();\n\nArrayList\nsize\ncars.size();\n\nArrayList\nfor\n\nsize()\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (int i = 0; i < cars.size(); i++) {\n      System.out.println(cars.get(i));\n    }\n  }\n}\n\nArrayList\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nArrayList\nString\nint\nInteger\nBoolean\nCharacter\nDouble\nArrayList\nInteger\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(10);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(25);\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\njava.util\nCollections\nsort()\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    Collections.sort(cars);  // Sort cars\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers);  // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nList\nArrayList\nimport java.util.List;\nimport java.util.ArrayList;\n\nList<String> cars = new ArrayList<>();\nList\nArrayList",
  "Java LinkedList\n\nIn the previous chapter, you learned about the ArrayList class. The LinkedList class is almost identical to the ArrayList:\n\nTry it Yourself »\n\nThe LinkedList class is a collection which can contain many objects of the same type, just like the ArrayList.\n\nThe LinkedList class has the same methods as ArrayList because both follow the List interface. This means you can add, change, remove, or clear elements in a LinkedList just like you would with an ArrayList.\n\nHowever, while the ArrayList class and the LinkedList class can be used in the same way, they are built very differently.\n\nThe ArrayList class has a regular array inside it. When an element is added, it is placed into the array. If the array is not big enough, a new, larger array is created to replace the old one and the old one is removed.\n\nThe LinkedList stores its elements in \"containers.\" The list has a link to the first container and each container has a link to the next container in the list. To add an element to the list, the element is placed into a new container and that container is linked to one of the other containers in the list.\n\nUse an ArrayList for storing and accessing data, and LinkedList to manipulate data.\n\nFor many cases, the ArrayList is more efficient as it is common to need access to random elements in the list, but the LinkedList provides several methods to do certain operations more efficiently:\n\nFor a complete reference of LinkedList methods, go to our Java LinkedList Reference.\n\n// Import the LinkedList class\nimport java.util.LinkedList;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedList<String> cars = new LinkedList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\nArrayList\nLinkedList\nArrayList\n// Import the LinkedList class\nimport java.util.LinkedList;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedList<String> cars = new LinkedList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\nLinkedList\nArrayList\nLinkedList\nArrayList\nList\nLinkedList\nArrayList\nArrayList\nLinkedList\nArrayList\nLinkedList\nArrayList\nLinkedList\nArrayList\nLinkedList\naddFirst()\naddLast()\nremoveFirst()\nremoveLast()\ngetFirst()\ngetLast()",
  "Java List Sorting\n\nIn the previous chapters, you learned how to use two popular lists in Java: ArrayList and LinkedList, which are found in the java.util package. Another useful class in the java.util package is the Collections class, which include the sort() method for sorting lists alphabetically or numerically. Sort an ArrayList Sort an ArrayList of Strings alphabetically in ascending order: Example import java.util.ArrayList; import java.util.Collections; // Import the Collections class public class Main { public static void main(String[] args) { ArrayList<String> cars = new ArrayList<String>(); cars.add(\"Volvo\"); cars.add(\"BMW\"); cars.add(\"Ford\"); cars.add(\"Mazda\"); Collections.sort(cars); // Sort cars for (String i : cars) { System.out.println(i); } } } Try it Yourself » Sort an ArrayList of Integers numerically in ascending order: Example import java.util.ArrayList; import java.util.Collections; // Import the Collections class public class Main { public static void main(String[] args) { ArrayList<Integer> myNumbers = new ArrayList<Integer>(); myNumbers.add(33); myNumbers.add(15); myNumbers.add(20); myNumbers.add(34); myNumbers.add(8); myNumbers.add(12); Collections.sort(myNumbers); // Sort myNumbers for (int i : myNumbers) { System.out.println(i); } } } Try it Yourself » Reverse the Order You can also sort a list in reverse order, by using the reverseOrder() method. In the following example, we sort an ArrayList of Strings alphabetically in reverse/descending order: Example import java.util.ArrayList; import java.util.Collections; // Import the Collections class public class Main { public static void main(String[] args) { ArrayList<String> cars = new ArrayList<String>(); cars.add(\"Volvo\"); cars.add(\"BMW\"); cars.add(\"Ford\"); cars.add(\"Mazda\"); Collections.sort(cars, Collections.reverseOrder()); // Sort cars for (String i : cars) { System.out.println(i); } } } Try it Yourself » Sort an ArrayList of Integers numerically in reverse/descending order: Example import java.util.ArrayList; import java.util.Collections; // Import the Collections class public class Main { public static void main(String[] args) { ArrayList<Integer> myNumbers = new ArrayList<Integer>(); myNumbers.add(33); myNumbers.add(15); myNumbers.add(20); myNumbers.add(34); myNumbers.add(8); myNumbers.add(12); Collections.sort(myNumbers, Collections.reverseOrder()); // Sort myNumbers for (int i : myNumbers) { System.out.println(i); } } } Try it Yourself » ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nAnother useful class in the java.util package is the Collections class, which include the sort() method for sorting lists alphabetically or numerically.\n\nSort an ArrayList of Strings alphabetically in ascending order:\n\nTry it Yourself »\n\nSort an ArrayList of Integers numerically in ascending order:\n\nTry it Yourself »\n\nYou can also sort a list in reverse order, by using the reverseOrder() method.\n\nIn the following example, we sort an ArrayList of Strings alphabetically in reverse/descending order:\n\nTry it Yourself »\n\nSort an ArrayList of Integers numerically in reverse/descending order:\n\nTry it Yourself »\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    Collections.sort(cars);  // Sort cars\n\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers);  // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    Collections.sort(cars, Collections.reverseOrder()); // Sort cars\n\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers, Collections.reverseOrder()); // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nArrayList\nLinkedList\njava.util\njava.util\nCollections\nsort()\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    Collections.sort(cars);  // Sort cars\n\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers);  // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nreverseOrder()\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    Collections.sort(cars, Collections.reverseOrder()); // Sort cars\n\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;  // Import the Collections class\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Collections.sort(myNumbers, Collections.reverseOrder()); // Sort myNumbers\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n",
  "Java Set\n\nThe Set interface is part of the Java Collections Framework and is used to store a collection of unique elements.\n\nUnlike a List, a Set does not allow duplicates, and it does not preserve the order of elements (unless you're using TreeSet or LinkedHashSet).\n\nCommon classes that implement Set:\n\nTip: Use a Set when you need to store unique values only.\n\nNext, you'll explore the HashSet class in detail.\n\nSet\nList\nSet\nTreeSet\nLinkedHashSet\nSet\nHashSet\nTreeSet\nLinkedHashSet\nSet\nadd()\nremove()\ncontains()\nsize()\nclear()\nHashSet",
  "Java HashSet\n\nA HashSet is a collection of elements where every element is unique.\n\nIt is part of the java.util package and implements the Set interface.\n\nCreate a HashSet object called cars that will store strings:\n\nNow you can use methods like add(), contains(), and remove() to manage your collection of unique elements.\n\nTo add elements to a HashSet, use the add() method:\n\nTry it Yourself »\n\nNote: In the example above, even though \"BMW\" is added twice, it only appears once in the set because sets do not allow duplicate elements.\n\nTo check whether an element exists in a HashSet, use the contains() method:\n\nTry it Yourself »\n\nTo remove an element, use the remove() method:\n\nTry it Yourself »\n\nTo remove all elements, use the clear() method:\n\nTry it Yourself »\n\nUse size() to count how many unique elements are in the set:\n\nTry it Yourself »\n\nNote: Duplicate values are not counted - only unique elements are included in the size.\n\nLoop through the elements of an HashSet with a for-each loop:\n\nTry it Yourself »\n\nElements in an HashSet are actually objects. In the examples above, we created elements (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nUse a HashSet that stores Integer objects:\n\nTry it Yourself »\n\nIn the next chapter, you will learn about TreeSet, which stores unique elements in sorted order.\n\nimport java.util.HashSet; // Import the HashSet class\n\nHashSet<String> cars = new HashSet<String>();\n\n// Import the HashSet class\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    HashSet<String> cars = new HashSet<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\ncars.contains(\"Mazda\");\n\ncars.remove(\"Volvo\");\n\ncars.clear();\n\ncars.size();\n\nfor (String i : cars) {\n  System.out.println(i);\n}\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashSet object called numbers\n    HashSet<Integer> numbers = new HashSet<Integer>();\n\n    // Add values to the set\n    numbers.add(4);\n    numbers.add(7);\n    numbers.add(8);\n\n    // Show which numbers between 1 and 10 are in the set\n    for (int i = 1; i <= 10; i++) {\n      if (numbers.contains(i)) {\n        System.out.println(i + \" was found in the set.\");\n      } else {\n        System.out.println(i + \" was not found in the set.\");\n      }\n    }\n  }\n}\n\nHashSet\njava.util\nSet\nHashSet\nimport java.util.HashSet; // Import the HashSet class\n\nHashSet<String> cars = new HashSet<String>();\n\nadd()\ncontains()\nremove()\nHashSet\nadd()\n// Import the HashSet class\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    HashSet<String> cars = new HashSet<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n    System.out.println(cars);\n  }\n}\n\n\"BMW\"\nHashSet\ncontains()\ncars.contains(\"Mazda\");\n\nremove()\ncars.remove(\"Volvo\");\n\nclear()\ncars.clear();\n\nsize()\ncars.size();\n\nHashSet\nfor (String i : cars) {\n  System.out.println(i);\n}\nHashSet\nString\nint\nInteger\nBoolean\nCharacter\nDouble\nHashSet\nInteger\nimport java.util.HashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashSet object called numbers\n    HashSet<Integer> numbers = new HashSet<Integer>();\n\n    // Add values to the set\n    numbers.add(4);\n    numbers.add(7);\n    numbers.add(8);\n\n    // Show which numbers between 1 and 10 are in the set\n    for (int i = 1; i <= 10; i++) {\n      if (numbers.contains(i)) {\n        System.out.println(i + \" was found in the set.\");\n      } else {\n        System.out.println(i + \" was not found in the set.\");\n      }\n    }\n  }\n}\n\nTreeSet",
  "Java TreeSet\n\nA TreeSet is a collection that stores unique elements in sorted order.\n\nIt is part of the java.util package and implements the Set interface.\n\nTip: Unlike HashSet, which has no order, TreeSet keeps its elements sorted automatically.\n\nCreate a TreeSet object called cars that will store strings:\n\nNow you can use methods like add(), contains(), and remove() to manage your sorted set of elements.\n\nTo add elements to a TreeSet, use the add() method:\n\nTry it Yourself »\n\nOutput: The elements will be sorted automatically (e.g., [BMW, Ford, Mazda, Volvo]).\n\nNote: Duplicates like \"BMW\" will only appear once.\n\nUse contains() to check if an element exists:\n\nTry it Yourself »\n\nUse remove() to remove an element:\n\nTry it Yourself »\n\nUse clear() to remove all elements:\n\nTry it Yourself »\n\nUse size() to count how many unique elements are in the set:\n\nTry it Yourself »\n\nNote: Duplicate values are not counted - only unique elements are included in the size.\n\nLoop through the elements of a TreeSet with a for-each loop:\n\nTry it Yourself »\n\nTreeSet also works with numbers and sorts them from smallest to largest:\n\nTry it Yourself »\n\nOutput: The numbers will be printed in sorted order (10, 20, 30, 40).\n\nTip: Use HashSet when you care about speed, and TreeSet when you need sorted elements.\n\nimport java.util.TreeSet; // Import the TreeSet class\n\nTreeSet<String> cars = new TreeSet<>();\nimport java.util.TreeSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeSet<String> cars = new TreeSet<>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n\n    System.out.println(cars);\n  }\n}\ncars.contains(\"Mazda\");\ncars.remove(\"Volvo\");\ncars.clear();\ncars.size();\nTreeSet<String> cars = new TreeSet<>();\n// add elements...\n\nfor (String i : cars) {\n  System.out.println(i);\n}\nimport java.util.TreeSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeSet<Integer> numbers = new TreeSet<>();\n    numbers.add(40);\n    numbers.add(10);\n    numbers.add(30);\n    numbers.add(20);\n\n    for (int n : numbers) {\n      System.out.println(n);\n    }\n  }\n}\nTreeSet\njava.util\nSet\nHashSet\nTreeSet\nTreeSet\nimport java.util.TreeSet; // Import the TreeSet class\n\nTreeSet<String> cars = new TreeSet<>();\nadd()\ncontains()\nremove()\nTreeSet\nadd()\nimport java.util.TreeSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeSet<String> cars = new TreeSet<>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n\n    System.out.println(cars);\n  }\n}\ncontains()\ncars.contains(\"Mazda\");\nremove()\ncars.remove(\"Volvo\");\nclear()\ncars.clear();\nsize()\ncars.size();\nTreeSet\nTreeSet<String> cars = new TreeSet<>();\n// add elements...\n\nfor (String i : cars) {\n  System.out.println(i);\n}\nTreeSet\nimport java.util.TreeSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeSet<Integer> numbers = new TreeSet<>();\n    numbers.add(40);\n    numbers.add(10);\n    numbers.add(30);\n    numbers.add(20);\n\n    for (int n : numbers) {\n      System.out.println(n);\n    }\n  }\n}\nHashSet\nTreeSet\nHashSet\nTreeSet",
  "Java LinkedHashSet\n\nA LinkedHashSet is a collection that stores unique elements and remembers the order they were added.\n\nIt is part of the java.util package and implements the Set interface.\n\nTip: Use LinkedHashSet when you want a set that does not allow duplicates and keeps the original insertion order.\n\nCreate a LinkedHashSet object called cars that will store strings:\n\nNow you can use methods like add(), contains(), and remove() to manage your collection.\n\nTo add elements to a LinkedHashSet, use the add() method:\n\nTry it Yourself »\n\nOutput: The elements will appear in the order they were added (e.g., [Volvo, BMW, Ford, Mazda]).\n\nNote: Duplicates like \"BMW\" are ignored.\n\nUse contains() to check for an element:\n\nTry it Yourself »\n\nUse remove() to remove an element:\n\nTry it Yourself »\n\nUse clear() to remove all elements:\n\nTry it Yourself »\n\nUse size() to count how many unique elements are in the set:\n\nTry it Yourself »\n\nNote: Duplicate values are not counted - only unique elements are included in the size.\n\nLoop through the elements of a LinkedHashSet with a for-each loop:\n\nTry it Yourself »\n\nTip: Use HashSet when you only care about uniqueness and speed. Use LinkedHashSet when order matters.\n\nimport java.util.LinkedHashSet; // Import the LinkedHashSet class\n\nLinkedHashSet<String> cars = new LinkedHashSet<>();\nimport java.util.LinkedHashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedHashSet<String> cars = new LinkedHashSet<>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n\n    System.out.println(cars);\n  }\n}\ncars.contains(\"Mazda\");\ncars.remove(\"Volvo\");\ncars.clear();\ncars.size();\nLinkedHashSet<String> cars = new LinkedHashSet<>();\n// Add elements...\n\nfor (String car : cars) {\n  System.out.println(car);\n}\nLinkedHashSet\njava.util\nSet\nLinkedHashSet\nLinkedHashSet\nimport java.util.LinkedHashSet; // Import the LinkedHashSet class\n\nLinkedHashSet<String> cars = new LinkedHashSet<>();\nadd()\ncontains()\nremove()\nLinkedHashSet\nadd()\nimport java.util.LinkedHashSet;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedHashSet<String> cars = new LinkedHashSet<>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"BMW\");  // Duplicate\n    cars.add(\"Mazda\");\n\n    System.out.println(cars);\n  }\n}\ncontains()\ncars.contains(\"Mazda\");\nremove()\ncars.remove(\"Volvo\");\nclear()\ncars.clear();\nsize()\ncars.size();\nLinkedHashSet\nLinkedHashSet<String> cars = new LinkedHashSet<>();\n// Add elements...\n\nfor (String car : cars) {\n  System.out.println(car);\n}\nHashSet\nLinkedHashSet\nHashSet\nLinkedHashSet",
  "Java Map\n\nThe Map interface is a part of the Java Collections Framework and is used to store key-value pairs. Each key must be unique, but values can be duplicated.\n\nA Map is useful when you want to associate a key (like a name or ID) with a value (like an age or description).\n\nCommon classes that implement Map:\n\nTip: Use a Map when you want to associate values with unique keys, like storing user IDs with names.\n\nNext, we'll look at how to use HashMap to store items in key/value pairs.\n\nMap\nMap\nMap\nHashMap\nTreeMap\nLinkedHashMap\nMap\nput()\nget()\nremove()\ncontainsKey()\nkeySet()\nHashMap",
  "Java HashMap\n\nA HashMap stores items in key/value pairs, where each key maps to a specific value.\n\nIt is part of the java.util package and implements the Map interface.\n\nInstead of accessing elements by an index (like with ArrayList), you use a key to retrieve its associated value.\n\nA HashMap can store many different combinations, such as:\n\nCreate a HashMap object called capitalCities that will store String keys and String values:\n\nNow you can use methods like put() to add key/value pairs, get() to retrieve a value by key, and remove() to delete an entry - all by using keys instead of index numbers.\n\nTo add items to a HashMap, use the put() method:\n\nTry it Yourself »\n\nNote: In the example above, if the same key (like \"Norway\") is added more than once, the latest value will overwrite the previous one, because keys in a HashMap must be unique.\n\nTo access a value in the HashMap, use the get() method and refer to its key:\n\nTry it Yourself »\n\nTo remove an item, use the remove() method and refer to the key:\n\nTry it Yourself »\n\nTo remove all items, use the clear() method:\n\nTry it Yourself »\n\nTo find out how many items there are, use the size() method:\n\nTry it Yourself »\n\nNote: The size only counts unique keys. If a key is added more than once, only the latest value is kept.\n\nLoop through the items of a HashMap with a for-each loop.\n\nNote: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:\n\nTry it Yourself »\n\nTry it Yourself »\n\nTry it Yourself »\n\nKeys and values in a HashMap are actually objects. In the examples above, we used objects of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: Integer. For other primitive types, use: Boolean for boolean, Character for char, Double for double, etc:\n\nCreate a HashMap object called people that will store String keys and Integer values:\n\nTry it Yourself »\n\nFor a complete reference of HashMap methods, go to our Java HashMap Reference.\n\nIn the next chapter, you will learn about TreeMap, which stores key/value pairs in sorted order by key.\n\nimport java.util.HashMap; // Import the HashMap class\n\nHashMap<String, String> capitalCities = new HashMap<>();\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a HashMap object called capitalCities\n    HashMap<String, String> capitalCities = new HashMap<String, String>();\n\n    // Add keys and values (Country, City)\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\n\ncapitalCities.get(\"England\");\n\ncapitalCities.remove(\"England\");\n\ncapitalCities.clear();\n\ncapitalCities.size();\n\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\n\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashMap object called people\n    HashMap<String, Integer> people = new HashMap<String, Integer>();\n\n    // Add keys and values (Name, Age)\n    people.put(\"John\", 32);\n    people.put(\"Steve\", 30);\n    people.put(\"Angie\", 33);\n\n    for (String i : people.keySet()) {\n      System.out.println(\"key: \" + i + \" value: \" + people.get(i));\n    }\n  }\n}\n\nHashMap\njava.util\nMap\nHashMap\nString\nInteger\nString\nString\nHashMap\ncapitalCities\nString\nString\nimport java.util.HashMap; // Import the HashMap class\n\nHashMap<String, String> capitalCities = new HashMap<>();\nput()\nget()\nremove()\nHashMap\nput()\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a HashMap object called capitalCities\n    HashMap<String, String> capitalCities = new HashMap<String, String>();\n\n    // Add keys and values (Country, City)\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\n\nHashMap\nHashMap\nget()\ncapitalCities.get(\"England\");\n\nremove()\ncapitalCities.remove(\"England\");\n\nclear()\ncapitalCities.clear();\n\nsize()\ncapitalCities.size();\n\nHashMap\nkeySet()\nvalues()\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\n\nHashMap\nString\nint\nInteger\nBoolean\nCharacter\nDouble\nHashMap\nString\n\nInteger\n// Import the HashMap class\nimport java.util.HashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Create a HashMap object called people\n    HashMap<String, Integer> people = new HashMap<String, Integer>();\n\n    // Add keys and values (Name, Age)\n    people.put(\"John\", 32);\n    people.put(\"Steve\", 30);\n    people.put(\"Angie\", 33);\n\n    for (String i : people.keySet()) {\n      System.out.println(\"key: \" + i + \" value: \" + people.get(i));\n    }\n  }\n}\n\nTreeMap",
  "Java TreeMap\n\nA TreeMap is a collection that stores key/value pairs in sorted order by key.\n\nIt is part of the java.util package and implements the Map interface.\n\nTip: Unlike HashMap, which does not maintain order, TreeMap keeps its keys sorted.\n\nCreate a TreeMap that stores String keys and String values:\n\nNow you can use methods like put(), get(), and remove() to manage sorted key/value pairs.\n\nUse the put() method to add key/value pairs:\n\nTry it Yourself »\n\nOutput: The keys are sorted alphabetically (e.g., {Austria=Wien, England=London, India=New Dehli, Norway=Oslo, USA=Washington DC}).\n\nNote: Duplicates like \"Norway\" will only appear once.\n\nUse get() with the key to access its value:\n\nTry it Yourself »\n\nUse remove() to delete a key/value pair by key:\n\nTry it Yourself »\n\nUse clear() to remove all items:\n\nTry it Yourself »\n\nUse size() to count the number of key/value pairs:\n\nTry it Yourself »\n\nNote: The size only counts unique keys. If a key is added more than once, only the latest value is kept.\n\nLoop through the items of a TreeMap with a for-each loop.\n\nNote: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:\n\nTry it Yourself »\n\nTry it Yourself »\n\nTry it Yourself »\n\nTip: Use HashMap for performance, and TreeMap when you need sorted keys.\n\nimport java.util.TreeMap; // Import the TreeMap class\n\nTreeMap<String, String> capitalCities = new TreeMap<>();\nimport java.util.TreeMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeMap<String, String> capitalCities = new TreeMap<>();\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\ncapitalCities.get(\"England\");\ncapitalCities.remove(\"England\");\ncapitalCities.clear();\ncapitalCities.size();\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\nTreeMap\njava.util\nMap\nHashMap\nTreeMap\nTreeMap\nString\nString\nimport java.util.TreeMap; // Import the TreeMap class\n\nTreeMap<String, String> capitalCities = new TreeMap<>();\nput()\nget()\nremove()\nput()\nimport java.util.TreeMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    TreeMap<String, String> capitalCities = new TreeMap<>();\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\nget()\ncapitalCities.get(\"England\");\nremove()\ncapitalCities.remove(\"England\");\nclear()\ncapitalCities.clear();\nsize()\ncapitalCities.size();\nTreeMap\nkeySet()\nvalues()\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\nHashMap\nTreeMap\nHashMap\nTreeMap",
  "Java LinkedHashMap\n\nA LinkedHashMap stores keys and values, and keeps them in the same order you put them in.\n\nIt is part of the java.util package and implements the Map interface.\n\nTip: Use LinkedHashMap when you want predictable iteration order (insertion order).\n\nCreate a LinkedHashMap object called capitalCities that will store String keys and String values:\n\nNow you can use methods like put() to add key/value pairs, get() to retrieve a value by key, and remove() to delete an entry - all while maintaining insertion order.\n\nUse the put() method to add items to the LinkedHashMap:\n\nTry it Yourself »\n\nOutput: The items will appear in the order they were added (e.g., {England=London, India=New Dehli, Austria=Wien, Norway=Oslo, USA=Washington DC}).\n\nNote: Duplicates like \"Norway\" are ignored.\n\nUse get() with a key to get its associated value:\n\nTry it Yourself »\n\nUse remove() to remove an item by key:\n\nTry it Yourself »\n\nUse clear() to remove all items:\n\nTry it Yourself »\n\nUse size() to check how many key/value pairs are in the map:\n\nTry it Yourself »\n\nNote: The size only counts unique keys. If a key is added more than once, only the latest value is kept.\n\nYou can loop through a LinkedHashMap using a for-each loop. Use:\n\nTry it Yourself »\n\nTry it Yourself »\n\nTry it Yourself »\n\nTip: Use LinkedHashMap when you want the map to remember the order in which entries were added.\n\nimport java.util.LinkedHashMap; // Import the LinkedHashMap class\n\nLinkedHashMap<String, String> capitalCities = new LinkedHashMap<>();\n// Import the LinkedHashMap class\nimport java.util.LinkedHashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedHashMap<String, String> capitalCities = new LinkedHashMap<>();\n\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\ncapitalCities.get(\"England\");\ncapitalCities.remove(\"England\");\ncapitalCities.clear();\ncapitalCities.size();\n// Print keys\nfor (String key : capitalCities.keySet()) {\n  System.out.println(key);\n}\n// Print values\nfor (String value : capitalCities.values()) {\n  System.out.println(value);\n}\n// Print keys and values\nfor (String key : capitalCities.keySet()) {\n  System.out.println(\"Key: \" + key + \", Value: \" + capitalCities.get(key));\n}\nLinkedHashMap\njava.util\nMap\nLinkedHashMap\nLinkedHashMap\ncapitalCities\nString\nString\nimport java.util.LinkedHashMap; // Import the LinkedHashMap class\n\nLinkedHashMap<String, String> capitalCities = new LinkedHashMap<>();\nput()\nget()\nremove()\nput()\nLinkedHashMap\n// Import the LinkedHashMap class\nimport java.util.LinkedHashMap;\n\npublic class Main {\n  public static void main(String[] args) {\n    LinkedHashMap<String, String> capitalCities = new LinkedHashMap<>();\n\n    capitalCities.put(\"England\", \"London\");\n    capitalCities.put(\"India\", \"New Dehli\");\n    capitalCities.put(\"Austria\", \"Wien\");\n    capitalCities.put(\"Norway\", \"Oslo\");\n    capitalCities.put(\"Norway\", \"Oslo\"); // Duplicate\n    capitalCities.put(\"USA\", \"Washington DC\");\n\n    System.out.println(capitalCities);\n  }\n}\nget()\ncapitalCities.get(\"England\");\nremove()\ncapitalCities.remove(\"England\");\nclear()\ncapitalCities.clear();\nsize()\ncapitalCities.size();\nLinkedHashMap\nkeySet()\nvalues()\n// Print keys\nfor (String key : capitalCities.keySet()) {\n  System.out.println(key);\n}\n// Print values\nfor (String value : capitalCities.values()) {\n  System.out.println(value);\n}\n// Print keys and values\nfor (String key : capitalCities.keySet()) {\n  System.out.println(\"Key: \" + key + \", Value: \" + capitalCities.get(key));\n}\nHashMap\nLinkedHashMap\nLinkedHashMap",
  "Java Iterator\n\nAn Iterator is an object that can be used to loop through collections, like ArrayList and HashSet.\n\nIt is called an \"iterator\" because \"iterating\" is the technical term for looping.\n\nTo use an Iterator, you must import it from the java.util package.\n\nThe iterator() method can be used to get an Iterator for any collection:\n\nTry it Yourself »\n\nTo loop through a collection, use the hasNext() and next() methods of the Iterator:\n\nTry it Yourself »\n\nIterators are designed to easily change the collections that they loop through. The remove() method can remove items from a collection while looping.\n\nUse an iterator to remove numbers less than 10 from a collection:\n\nTry it Yourself »\n\nNote: Trying to remove items using a for loop or a for-each loop would not work correctly because the collection is changing size at the same time that the code is trying to loop.\n\n// Import the ArrayList class and the Iterator class\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Make a collection\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    // Get the iterator\n    Iterator<String> it = cars.iterator();\n\n    // Print the first item\n    System.out.println(it.next());\n  }\n}\n\nwhile(it.hasNext()) {\n  System.out.println(it.next());\n}\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(12);\n    numbers.add(8);\n    numbers.add(2);\n    numbers.add(23);\n    Iterator<Integer> it = numbers.iterator();\n    while(it.hasNext()) {\n      Integer i = it.next();\n      if(i < 10) {\n        it.remove();\n      }\n    }\n    System.out.println(numbers);\n  }\n}\nIterator\nArrayList\nHashSet\njava.util\niterator()\nIterator\n// Import the ArrayList class and the Iterator class\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    // Make a collection\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n\n    // Get the iterator\n    Iterator<String> it = cars.iterator();\n\n    // Print the first item\n    System.out.println(it.next());\n  }\n}\n\nhasNext()\nnext()\nIterator\nwhile(it.hasNext()) {\n  System.out.println(it.next());\n}\nremove()\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(12);\n    numbers.add(8);\n    numbers.add(2);\n    numbers.add(23);\n    Iterator<Integer> it = numbers.iterator();\n    while(it.hasNext()) {\n      Integer i = it.next();\n      if(i < 10) {\n        it.remove();\n      }\n    }\n    System.out.println(numbers);\n  }\n}",
  "Java Wrapper Classes\n\nWrapper classes provide a way to use primitive data types (int, boolean, etc..) as objects.\n\nThe table below shows the primitive type and the equivalent wrapper class:\n\nSometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store objects):\n\nTry it Yourself »\n\nTo create a wrapper object, use the wrapper class instead of the primitive type. To get the value, you can just print the object:\n\nTry it Yourself »\n\nSince you're now working with objects, you can use certain methods to get information about the specific object.\n\nFor example, the following methods are used to get the value associated with the corresponding wrapper object: intValue(), byteValue(), shortValue(), longValue(), floatValue(), doubleValue(), charValue(), booleanValue().\n\nThis example will output the same result as the example above:\n\nTry it Yourself »\n\nAnother useful method is the toString() method, which is used to convert wrapper objects to strings.\n\nIn the following example, we convert an Integer to a String, and use the length() method of the String class to output the length of the \"string\":\n\nTry it Yourself »\n\nArrayList<int> myNumbers = new ArrayList<int>(); // Invalid\n\nArrayList<Integer> myNumbers = new ArrayList<Integer>(); // Valid\n\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 5;\n    Double myDouble = 5.99;\n    Character myChar = 'A';\n    System.out.println(myInt);\n    System.out.println(myDouble);\n    System.out.println(myChar);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 5;\n    Double myDouble = 5.99;\n    Character myChar = 'A';\n    System.out.println(myInt.intValue());\n    System.out.println(myDouble.doubleValue());\n    System.out.println(myChar.charValue());\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 100;\n    String myString = myInt.toString();\n    System.out.println(myString.length());\n  }\n}\n\nint\nboolean\nArrayList\nArrayList<int> myNumbers = new ArrayList<int>(); // Invalid\n\nArrayList<Integer> myNumbers = new ArrayList<Integer>(); // Valid\n\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 5;\n    Double myDouble = 5.99;\n    Character myChar = 'A';\n    System.out.println(myInt);\n    System.out.println(myDouble);\n    System.out.println(myChar);\n  }\n}\n\nintValue()\nbyteValue()\nshortValue()\nlongValue()\nfloatValue()\ndoubleValue()\ncharValue()\n\nbooleanValue()\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 5;\n    Double myDouble = 5.99;\n    Character myChar = 'A';\n    System.out.println(myInt.intValue());\n    System.out.println(myDouble.doubleValue());\n    System.out.println(myChar.charValue());\n  }\n}\n\ntoString()\nInteger\nString\nlength()\nString\npublic class Main {\n  public static void main(String[] args) {\n    Integer myInt = 100;\n    String myString = myInt.toString();\n    System.out.println(myString.length());\n  }\n}\n",
  "Java Generics\n\nGenerics allow you to write classes, interfaces, and methods that work with different data types, without having to specify the exact type in advance.\n\nThis makes your code more flexible, reusable, and type-safe.\n\nYou can create a class that works with different data types using generics:\n\nTry it Yourself »\n\nT is a generic type parameter. It's like a placeholder for a data type.\n\nThis way, the same class can be reused with different data types without rewriting the code.\n\nYou can also create methods that work with any data type using generics:\n\nTry it Yourself »\n\nThis is useful when you want to write one method that works with multiple types, instead of repeating code for each one.\n\nYou can use the extends keyword to limit the types a generic class or method can accept.\n\nFor example, you can require that the type must be a subclass of Number:\n\nTry it Yourself »\n\nEven though int values are used in the first case, the .doubleValue() method converts them to double, so the result is shown with a decimal point.\n\nJava Collections like ArrayList and HashMap use generics internally:\n\nT\nBox<String>\nT\nString\nBox<Integer>\nT\nInteger\n<T>\nString\nInteger\nDouble\nprintArray()\nT\nT\nextends\nNumber\nint\n.doubleValue()\ndouble\n<T extends Number>\nT\nInteger\nDouble\nFloat\n.doubleValue()\ndouble\nNumber\nArrayList\nHashMap\nT\nExemple:\n\nclass Box<T> {\n  T value; // T is a placeholder for any data type\n\n  void set(T value) {\n    this.value = value;\n  }\n\n  T get() {\n    return value;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    // Create a Box to hold a String\n    Box<String> stringBox = new Box<>();\n    stringBox.set(\"Hello\");\n    System.out.println(\"Value: \" + stringBox.get());\n\n    // Create a Box to hold an Integer\n    Box<Integer> intBox = new Box<>();\n    intBox.set(50);\n    System.out.println(\"Value: \" + intBox.get());\n  }\n}\n\nExemple:\n\npublic class Main {\n  // Generic method: works with any type T\n  public static <T> void printArray(T[] array) {\n    for (T item : array) {\n      System.out.println(item);\n    }\n  }\n\n  public static void main(String[] args) {\n    // Array of Strings\n    String[] names = {\"Jenny\", \"Liam\"};\n\n    // Array of Integers\n    Integer[] numbers = {1, 2, 3};\n\n    // Call the generic method with both arrays\n    printArray(names);\n    printArray(numbers);\n  }\n}\n\nExemple:\n\nclass Stats<T extends Number> {\n  T[] nums;\n\n  // Constructor\n  Stats(T[] nums) {\n    this.nums = nums;\n  }\n\n  // Calculate average\n  double average() {\n    double sum = 0;\n    for (T num : nums) {\n      sum += num.doubleValue();\n    }\n    return sum / nums.length;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    // Use with Integer\n    Integer[] intNums = {10, 20, 30, 40};\n    Stats<Integer> intStats = new Stats<>(intNums);\n    System.out.println(\"Integer average: \" + intStats.average());\n\n    // Use with Double\n    Double[] doubleNums = {1.5, 2.5, 3.5};\n    Stats<Double> doubleStats = new Stats<>(doubleNums);\n    System.out.println(\"Double average: \" + doubleStats.average());\n  }\n}\n\nExemple:\n\nArrayList<String> list = new ArrayList<>();\nlist.add(\"Apple\");\nString fruit = list.get(0); // No need to cast\n",
  "Java Annotations\n\nAnnotations are special notes you add to your Java code. They start with the @ symbol.\n\nThey don't change how your program runs, but they give extra information to the compiler or tools.\n\nJava includes several built-in annotations. Here are some of the most commonly used:\n\nThe @Override annotation helps the compiler check that a method really overrides a method from a superclass.\n\nIt's not required, but it's highly recommended because it helps catch errors.\n\nIn this example, we clearly indicate that we are overriding a method:\n\nTry it Yourself »\n\nIf you accidentally write the wrong method name (e.g. makesound()), the compiler will show an error like:\n\nResult:\n\nTry it Yourself »\n\nThat's the power of @Override - it prevents silent mistakes.\n\nIf you try to remove the @Override line in the example above, the compiler won't warn you, and the method won't override anything. Your program may still run, but it could behave unexpectedly because the intended method was never actually overridden.\n\nThe @Deprecated annotation warns developers not to use a method because it may be removed or replaced in the future:\n\nTry it Yourself »\n\nEven though the method runs and prints the message, most IDEs or compilers will show a warning like this:\n\nThe @SuppressWarnings annotation tells the compiler to ignore specific warnings, like \"unchecked\" or \"deprecation\":\n\nResult:\n\nTry it Yourself »\n\nUsing raw types like ArrayList without specifying a type (e.g. ArrayList<String>) usually causes an \"unchecked\" warning.\n\nThe annotation @SuppressWarnings(\"unchecked\") tells the compiler to ignore that warning. This is useful when working with old code or when you're sure the operation is safe.\n\nHowever, instead of hiding the warning, you can fix it like this:\n\nThis approach is type-safe and avoids the need for suppression.\n\n@\n@Override\n@Deprecated\n@SuppressWarnings\n@Override\nmakesound()\nMain.java:8: error: method does not override or implement a method from a supertype\n  @Override\n  ^\n1 error\n@Override\n@Override\n@Deprecated\nwarning: [deprecation] oldMethod() in Main has been deprecated\n@SuppressWarnings\n[Volvo]\nArrayList\nArrayList<String>\n@SuppressWarnings(\"unchecked\")\nExample:\n\n\nclass Animal {\n  void makeSound() {\n    System.out.println(\"Animal sound\");\n  }\n}\n\nclass Dog extends Animal {\n  @Override\n  void makeSound() {\n    System.out.println(\"Woof!\");\n  }\n}\nExample:\n\n\nclass Animal {\n  void makeSound() {\n    System.out.println(\"Animal sound\");\n  }\n}\n\nclass Dog extends Animal {\n  @Override\n  void makesound() { // Typo here!\n    System.out.println(\"Woof!\");\n  }\n}public class Main {\n  public static void main(String[] args) {\n    Animal myDog = new Dog();\n    myDog.makeSound();\n  }\n}\nExample:\n\npublic class Main {\n  @Deprecated\n  static void oldMethod() {\n    System.out.println(\"This method is outdated.\");\n  }\n\n  public static void main(String[] args) {\n        oldMethod(); // This will show a warning in most IDEs\n  }\n}\n  \nExemple:\n\nimport java.util.ArrayList;\n\npublic class Main {\n  @SuppressWarnings(\"unchecked\")\n  public static void main(String[] args) {\n    ArrayList cars = new ArrayList();\n    cars.add(\"Volvo\");\n    System.out.println(cars);\n  }\n}\n  \nExemple:\n\nArrayList<String> cars = new ArrayList<>();\n",
  "Java Regular Expressions\n\nA regular expression is a sequence of characters that forms a search pattern. When you search for data in a text, you can use this search pattern to describe what you are searching for.\n\nA regular expression can be a single character, or a more complicated pattern.\n\nRegular expressions can be used to perform all types of text search and text replace operations.\n\nJava does not have a built-in Regular Expression class, but we can import the java.util.regex package to work with regular expressions. The package includes the following classes:\n\nFind out if there are any occurrences of the word \"w3schools\" in a sentence:\n\nTry it Yourself »\n\nIn this example, The word \"w3schools\" is being searched for in a sentence.\n\nFirst, the pattern is created using the Pattern.compile() method. The first parameter indicates which pattern is being searched for and the second parameter has a flag to indicates that the search should be case-insensitive. The second parameter is optional.\n\nThe matcher() method is used to search for the pattern in a string. It returns a Matcher object which contains information about the search that was performed.\n\nThe find() method returns true if the pattern was found in the string and false if it was not found.\n\nFlags in the compile() method change how the search is performed. Here are a few of them:\n\nThe first parameter of the Pattern.compile() method is the pattern. It describes what is being searched for.\n\nBrackets are used to find a range of characters:\n\nMetacharacters are characters with a special meaning:\n\nQuantifiers define quantities:\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n  public static void main(String[] args) {\n    Pattern pattern = Pattern.compile(\"w3schools\", Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher(\"Visit W3Schools!\");\n    boolean matchFound = matcher.find();\n    if(matchFound) {\n      System.out.println(\"Match found\");\n    } else {\n      System.out.println(\"Match not found\");\n    }\n  }\n}\n// Outputs Match found\n\njava.util.regex\nPattern\nMatcher\nPatternSyntaxException\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n  public static void main(String[] args) {\n    Pattern pattern = Pattern.compile(\"w3schools\", Pattern.CASE_INSENSITIVE);\n    Matcher matcher = pattern.matcher(\"Visit W3Schools!\");\n    boolean matchFound = matcher.find();\n    if(matchFound) {\n      System.out.println(\"Match found\");\n    } else {\n      System.out.println(\"Match not found\");\n    }\n  }\n}\n// Outputs Match found\n\nPattern.compile()\nmatcher()\nfind()\ncompile()\nPattern.CASE_INSENSITIVE\nPattern.LITERAL\nPattern.UNICODE_CASE\nCASE_INSENSITIVE\nPattern.compile()",
  "Java Threads\n\nThreads allows a program to operate more efficiently by doing multiple things at the same time.\n\nThreads can be used to perform complicated tasks in the background without interrupting the main program.\n\nThere are two ways to create a thread.\n\nIt can be created by extending the Thread class and overriding its run() method:\n\nAnother way to create a thread is to implement the Runnable interface:\n\nIf the class extends the Thread class, the thread can be run by creating an instance of the class and call its start() method:\n\nTry it Yourself »\n\nIf the class implements the Runnable interface, the thread can be run by passing an instance of the class to a Thread object's constructor and then calling the thread's start() method:\n\nTry it Yourself »\n\nDifferences between \"extending\" and \"implementing\" Threads\n\nThe major difference is that when a class extends the Thread class, you cannot extend any other class, but by implementing the Runnable interface, it is possible to extend from another class as well, like: class MyClass extends OtherClass implements Runnable.\n\nBecause threads run at the same time as other parts of the program, there is no way to know in which order the code will run. When the threads and main program are reading and writing the same variables, the values are unpredictable. The problems that result from this are called concurrency problems.\n\nA code example where the value of the variable amount is unpredictable:\n\nTry it Yourself »\n\nTo avoid concurrency problems, it is best to share as few attributes between threads as possible. If attributes need to be shared, one possible solution is to use the isAlive() method of the thread to check whether the thread has finished running before using any attributes that the thread can change.\n\nUse isAlive() to prevent concurrency problems:\n\nTry it Yourself »\n\npublic class Main extends Thread {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\npublic class Main implements Runnable {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\npublic class Main extends Thread {\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\npublic class Main implements Runnable {\n  public static void main(String[] args) {\n    Main obj = new Main();\n    Thread thread = new Thread(obj);\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(amount);\n    amount++;\n    System.out.println(amount);\n  }\n\n  public void run() {\n    amount++;\n  }\n}\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    // Wait for the thread to finish\n    while(thread.isAlive()) {\n      System.out.println(\"Waiting...\");\n    }\n    // Update amount and print its value\n    System.out.println(\"Main: \" + amount);\n    amount++;\n    System.out.println(\"Main: \" + amount);\n  }\n  public void run() {\n    amount++;\n  }\n}\nThread\nrun()\npublic class Main extends Thread {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  \n\n\nRunnable\npublic class Main implements Runnable {\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\nThread\nstart()\npublic class Main extends Thread {\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\nRunnable\nThread\nstart()\npublic class Main implements Runnable {\n  public static void main(String[] args) {\n    Main obj = new Main();\n    Thread thread = new Thread(obj);\n    thread.start();\n    System.out.println(\"This code is outside of the thread\");\n  }\n  public void run() {\n    System.out.println(\"This code is running in a thread\");\n  }\n}\nMyClass extends OtherClass implements Runnable\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    System.out.println(amount);\n    amount++;\n    System.out.println(amount);\n  \n\n\n  public void run() {\n    amount++;\n  \n\n\nisAlive()\nisAlive()\npublic class Main extends Thread {\n  public static int amount = 0;\n\n  public static void main(String[] args) {\n    Main thread = new Main();\n    thread.start();\n    // Wait for the thread to finish\n    while(thread.isAlive()) {\n      System.out.println(\"Waiting...\");\n    \n\n    // Update amount and print its value\n    System.out.println(\"Main: \" + amount);\n    amount++;\n    System.out.println(\"Main: \" + amount);\n  \n\n  public void run() {\n    amount++;\n  \n\n",
  "Java Lambda Expressions\n\nLambda Expressions were added in Java 8.\n\nA lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.\n\nThe simplest lambda expression contains a single parameter and an expression:\n\nTo use more than one parameter, wrap them in parentheses:\n\nExpressions are limited. They have to immediately return a value, and they cannot contain variables, assignments or statements such as if or for. In order to do more complex operations, a code block can be used with curly braces. If the lambda expression needs to return a value, then the code block should have a return statement.\n\nLambda expressions are usually passed as parameters to a function:\n\nUse a lambda expression in the ArrayList's forEach() method to print every item in the list:\n\nTry it Yourself »\n\nLambda expressions can be stored in variables if the variable's type is an interface which has only one method. The lambda expression should have the same number of parameters and the same return type as that method. Java has many of these kinds of interfaces built in, such as the Consumer interface (found in the java.util package) used by lists.\n\nUse Java's Consumer interface to store a lambda expression in a variable:\n\nTry it Yourself »\n\nTo use a lambda expression in a method, the method should have a parameter with a single-method interface as its type. Calling the interface's method will run the lambda expression:\n\nCreate a method which takes a lambda expression as a parameter:\n\nTry it Yourself »\n\nparameter -> expression\n(parameter1, parameter2) -> expression\n(parameter1, parameter2) -> { code block }\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    numbers.forEach( (n) -> { System.out.println(n); } );\n  }\n}\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    Consumer<Integer> method = (n) -> { System.out.println(n); };\n    numbers.forEach( method );\n  }\n}\ninterface StringFunction {\n  String run(String str);\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    StringFunction exclaim = (s) -> s + \"!\";\n    StringFunction ask = (s) -> s + \"?\";\n    printFormatted(\"Hello\", exclaim);\n    printFormatted(\"Hello\", ask);\n  }\n  public static void printFormatted(String str, StringFunction format) {\n    String result = format.run(str);\n    System.out.println(result);\n  }\n}\nparameter -> expression\n(parameter1, parameter2) -> expression\nif\nfor\nreturn\n(parameter1, parameter2) -> { code block }\nArrayList\nforEach()\nimport java.util.ArrayList;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    numbers.forEach( (n) -> { System.out.println(n); } );\n  }\n}\nConsumer\njava.util\nConsumer\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> numbers = new ArrayList<Integer>();\n    numbers.add(5);\n    numbers.add(9);\n    numbers.add(8);\n    numbers.add(1);\n    Consumer<Integer> method = (n) -> { System.out.println(n); };\n    numbers.forEach( method );\n  }\n}\ninterface StringFunction {\n  String run(String str);\n\n\n\npublic class Main {\n  public static void main(String[] args) {\n    StringFunction exclaim = (s) -> s + \"!\";\n    StringFunction ask = (s) -> s + \"?\";\n    printFormatted(\"Hello\", exclaim);\n    printFormatted(\"Hello\", ask);\n  \n\n  public static void printFormatted(String str, StringFunction format) {\n    String result = format.run(str);\n    System.out.println(result);\n  \n\n",
  "Java Advanced Sorting (Comparator and Comparable)\n\nIn the List Sorting Chapter, you learned how to sort lists alphabetically and numerically, but what if the list has objects in it?\n\nTo sort objects you need to specify a rule that decides how objects should be sorted. For example, if you have a list of cars you might want to sort them by year, the rule could be that cars with an earlier year go first.\n\nThe Comparator and Comparable interfaces allow you to specify what rule is used to sort objects.\n\nBeing able to specify a sorting rule also allows you to change how strings and numbers are sorted.\n\nAn object that implements the Comparator interface is called a comparator.\n\nThe Comparator interface allows you to create a class with a compare() method that compares two objects to decide which one should go first in a list.\n\nThe compare() method should return a number which is:\n\nA class that implements the Comparator interface might look something like this:\n\nTo use the comparator, pass it as an argument into a sorting method:\n\nHere is a complete example using a comparator to sort a list of cars by year:\n\nTo make the code shorter, the comparator can be replaced with a lambda expression which has the same arguments and return value as the compare() method:\n\nUse a lambda expression as a comparator:\n\nComparators can also be used to make special sorting rules for strings and numbers. In this example we use a comparator to list all of the even numbers before the odd ones:\n\nThe Comparable interface allows an object to specify its own sorting rule with a compareTo() method.\n\nThe compareTo() method takes an object as an argument and compares the comparable with the argument to decide which one should go first in a list.\n\nLike the comparator, the compareTo() method returns a number which is:\n\nMany native Java classes implement the Comparable interface, such as String and Integer.\n\nThis is why strings and numbers do not need a comparator to be sorted.\n\nAn object that implements the Comparable interface might look something like this:\n\nHere is the same example as before but using the Comparable interface instead of a comparator:\n\nThe most obvious way to sort two numbers naturally is to write something like this:\n\nBut it can actually be done with just a single line:\n\nThis trick can also be used to easily sort things in reverse:\n\nA comparator is an object with one method that is used to compare two different objects.\n\nA comparable is an object which can compare itself with other objects.\n\nIt is easier to use the Comparable interface when possible, but the Comparator interface is more powerful because it allows you to sort any kind of object even if you cannot change its code. ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\n❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\n// Sort Car objects by year\nclass SortByYear implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure that the objects are Car objects\n    Car a = (Car) obj1;\n    Car b = (Car) obj2;\n    \n    // Compare the objects\n    if (a.year < b.year) return -1; // The first car has a smaller year\n    if (a.year > b.year) return 1;  // The first car has a larger year\n    return 0; // Both cars have the same year\n  }\n}\n\n// Use a comparator to sort the cars\nComparator myComparator = new SortByYear();\nCollections.sort(myCars, myComparator);\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n// Define a Car class\nclass Car {\n  public String brand;\n  public String model;\n  public int year;\n  \n  public Car(String b, String m, int y) {\n    brand = b;\n    model = m;\n    year = y;\n  }\n}\n\n// Create a comparator\nclass SortByYear implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure that the objects are Car objects\n    Car a = (Car) obj1;\n    Car b = (Car) obj2;\n    \n    // Compare the year of both objects\n    if (a.year < b.year) return -1; // The first car has a smaller year\n    if (a.year > b.year) return 1;  // The first car has a larger year\n    return 0; // Both cars have the same year\n  }\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    // Create a list of cars\n    ArrayList<Car> myCars = new ArrayList<Car>();    \n    myCars.add(new Car(\"BMW\", \"X5\", 1999));\n    myCars.add(new Car(\"Honda\", \"Accord\", 2006));\n    myCars.add(new Car(\"Ford\", \"Mustang\", 1970));\n\n    // Use a comparator to sort the cars\n    Comparator myComparator = new SortByYear();\n    Collections.sort(myCars, myComparator);\n\n    // Display the cars\n    for (Car c : myCars) {\n      System.out.println(c.brand + \" \" + c.model + \" \" + c.year);\n    }\n  } \n}\n\nCollections.sort(myCars, (obj1, obj2) -> {\n  Car a = (Car) obj1;\n  Car b = (Car) obj2;\n  if (a.year < b.year) return -1;\n  if (a.year > b.year) return 1;\n  return 0;\n});\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nclass SortEvenFirst implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure the objects are integers\n    Integer a = (Integer)obj1;\n    Integer b = (Integer)obj2;\n    \n    // Check each number to see if it is even\n    // A number is even if the remainder when dividing by 2 is 0\n    boolean aIsEven = (a % 2) == 0;\n    boolean bIsEven = (b % 2) == 0;\n    \n    if (aIsEven == bIsEven) {\n    \n      // If both numbers are even or both are odd then use normal sorting rules\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n      \n    } else {\n    \n      // If a is even then it goes first, otherwise b goes first\n      if (aIsEven) {\n      \treturn -1;\n      } else {\n        return 1;\n      }\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Comparator myComparator = new SortEvenFirst();\n    Collections.sort(myNumbers, myComparator);\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nclass Car implements Comparable {\n  public String brand;\n  public String model;\n  public int year;\n  \n  // Decide how this object compares to other objects\n  public int compareTo(Object obj) {\n  \tCar other = (Car)obj;\n    if(year < other.year) return -1; // This object is smaller than the other one\n    if(year > other.year) return 1;  // This object is larger than the other one\n    return 0; // Both objects are the same\n  }\n}\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n// Define a Car class which is comparable\nclass Car implements Comparable {\n  public String brand;\n  public String model;\n  public int year;\n  \n  public Car(String b, String m, int y) {\n    brand = b;\n    model = m;\n    year = y;\n  }\n  \n  // Decide how this object compares to other objects\n  public int compareTo(Object obj) {\n  \tCar other = (Car)obj;\n    if(year < other.year) return -1; // This object is smaller than the other one\n    if(year > other.year) return 1;  // This object is larger than the other one\n    return 0; // Both objects are the same\n  }\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    // Create a list of cars\n    ArrayList<Car> myCars = new ArrayList<Car>();    \n    myCars.add(new Car(\"BMW\", \"X5\", 1999));\n    myCars.add(new Car(\"Honda\", \"Accord\", 2006));\n    myCars.add(new Car(\"Ford\", \"Mustang\", 1970));\n\n    // Sort the cars\n    Collections.sort(myCars);\n\n    // Display the cars\n    for (Car c : myCars) {\n      System.out.println(c.brand + \" \" + c.model + \" \" + c.year);\n    }\n  } \n}\n\nif(a.year < b.year) return -1; // a is less than b\nif(a.year > b.year) return 1; // a is greater than b\nreturn 0; // a is equal to b\n\nreturn a.year - b.year;\nreturn b.year - a.year;\nComparator\nComparable\nComparator\nComparator\ncompare()\ncompare()\nComparator\n// Sort Car objects by year\nclass SortByYear implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure that the objects are Car objects\n    Car a = (Car) obj1;\n    Car b = (Car) obj2;\n    \n    // Compare the objects\n    if (a.year < b.year) return -1; // The first car has a smaller year\n    if (a.year > b.year) return 1;  // The first car has a larger year\n    return 0; // Both cars have the same year\n  }\n}\n\n// Use a comparator to sort the cars\nComparator myComparator = new SortByYear();\nCollections.sort(myCars, myComparator);\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n// Define a Car class\nclass Car {\n  public String brand;\n  public String model;\n  public int year;\n  \n  public Car(String b, String m, int y) {\n    brand = b;\n    model = m;\n    year = y;\n  }\n}\n\n// Create a comparator\nclass SortByYear implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure that the objects are Car objects\n    Car a = (Car) obj1;\n    Car b = (Car) obj2;\n    \n    // Compare the year of both objects\n    if (a.year < b.year) return -1; // The first car has a smaller year\n    if (a.year > b.year) return 1;  // The first car has a larger year\n    return 0; // Both cars have the same year\n  }\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    // Create a list of cars\n    ArrayList<Car> myCars = new ArrayList<Car>();    \n    myCars.add(new Car(\"BMW\", \"X5\", 1999));\n    myCars.add(new Car(\"Honda\", \"Accord\", 2006));\n    myCars.add(new Car(\"Ford\", \"Mustang\", 1970));\n\n    // Use a comparator to sort the cars\n    Comparator myComparator = new SortByYear();\n    Collections.sort(myCars, myComparator);\n\n    // Display the cars\n    for (Car c : myCars) {\n      System.out.println(c.brand + \" \" + c.model + \" \" + c.year);\n    }\n  } \n}\n\ncompare()\nCollections.sort(myCars, (obj1, obj2) -> {\n  Car a = (Car) obj1;\n  Car b = (Car) obj2;\n  if (a.year < b.year) return -1;\n  if (a.year > b.year) return 1;\n  return 0;\n});\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\nclass SortEvenFirst implements Comparator {\n  public int compare(Object obj1, Object obj2) {\n    // Make sure the objects are integers\n    Integer a = (Integer)obj1;\n    Integer b = (Integer)obj2;\n    \n    // Check each number to see if it is even\n    // A number is even if the remainder when dividing by 2 is 0\n    boolean aIsEven = (a % 2) == 0;\n    boolean bIsEven = (b % 2) == 0;\n    \n    if (aIsEven == bIsEven) {\n    \n      // If both numbers are even or both are odd then use normal sorting rules\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n      \n    } else {\n    \n      // If a is even then it goes first, otherwise b goes first\n      if (aIsEven) {\n      \treturn -1;\n      } else {\n        return 1;\n      }\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<Integer> myNumbers = new ArrayList<Integer>();\n    myNumbers.add(33);\n    myNumbers.add(15);\n    myNumbers.add(20);\n    myNumbers.add(34);\n    myNumbers.add(8);\n    myNumbers.add(12);\n\n    Comparator myComparator = new SortEvenFirst();\n    Collections.sort(myNumbers, myComparator);\n\n    for (int i : myNumbers) {\n      System.out.println(i);\n    }\n  }\n}\n\nComparable\ncompareTo()\ncompareTo()\ncompareTo()\nComparable\nString\nInteger\nComparable\nclass Car implements Comparable {\n  public String brand;\n  public String model;\n  public int year;\n  \n  // Decide how this object compares to other objects\n  public int compareTo(Object obj) {\n  \tCar other = (Car)obj;\n    if(year < other.year) return -1; // This object is smaller than the other one\n    if(year > other.year) return 1;  // This object is larger than the other one\n    return 0; // Both objects are the same\n  }\n}\n\nComparable\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n// Define a Car class which is comparable\nclass Car implements Comparable {\n  public String brand;\n  public String model;\n  public int year;\n  \n  public Car(String b, String m, int y) {\n    brand = b;\n    model = m;\n    year = y;\n  }\n  \n  // Decide how this object compares to other objects\n  public int compareTo(Object obj) {\n  \tCar other = (Car)obj;\n    if(year < other.year) return -1; // This object is smaller than the other one\n    if(year > other.year) return 1;  // This object is larger than the other one\n    return 0; // Both objects are the same\n  }\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    // Create a list of cars\n    ArrayList<Car> myCars = new ArrayList<Car>();    \n    myCars.add(new Car(\"BMW\", \"X5\", 1999));\n    myCars.add(new Car(\"Honda\", \"Accord\", 2006));\n    myCars.add(new Car(\"Ford\", \"Mustang\", 1970));\n\n    // Sort the cars\n    Collections.sort(myCars);\n\n    // Display the cars\n    for (Car c : myCars) {\n      System.out.println(c.brand + \" \" + c.model + \" \" + c.year);\n    }\n  } \n}\n\nif(a.year < b.year) return -1; // a is less than b\nif(a.year > b.year) return 1; // a is greater than b\nreturn 0; // a is equal to b\n\nreturn a.year - b.year;\nreturn b.year - a.year;\nComparable\nComparator",
  "Java How To Add Two Numbers\n\nLearn how to add two numbers in Java:\n\nLearn how to add two numbers with user input:\n\nint x = 5;\nint y = 6;\nint sum = x + y;\nSystem.out.println(sum); // Print the sum of x + y\nimport java.util.Scanner; // Import the Scanner class\n\nclass MyClass {\n  public static void main(String[] args) {\n    int x, y, sum;\n    Scanner myObj = new Scanner(System.in); // Create a Scanner object\n    System.out.println(\"Type a number:\");\n    x = myObj.nextInt(); // Read user input\n\n    System.out.println(\"Type another number:\");\n    y = myObj.nextInt(); // Read user input\n\n    sum = x + y;  // Calculate the sum of x + y\n    System.out.println(\"Sum is: \" + sum); // Print the sum\n  }\n} \nint x = 5;\nint y = 6;\nint sum = x + y;\nSystem.out.println(sum); // Print the sum of x + y\nimport java.util.Scanner; // Import the Scanner class\n\nclass MyClass {\n  public static void main(String[] args) {\n    int x, y, sum;\n    Scanner myObj = new Scanner(System.in); // Create a Scanner object\n    System.out.println(\"Type a number:\");\n    x = myObj.nextInt(); // Read user input\n\n    System.out.println(\"Type another number:\");\n    y = myObj.nextInt(); // Read user input\n\n    sum = x + y;  // Calculate the sum of x + y\n    System.out.println(\"Sum is: \" + sum); // Print the sum\n  }\n} ",
  "Java How To Count Words\n\nYou can easily count the number of words in a string with the following example:\n\nJava String Tutorial\n\nJava String Methods\n\nString words = \"One Two Three Four\";\nint countWords = words.split(\"\\\\s\").length;\nSystem.out.println(countWords);\nString words = \"One Two Three Four\";\nint countWords = words.split(\"\\\\s\").length;\nSystem.out.println(countWords);",
  "Java How To Reverse a String\n\nYou can easily reverse a string by characters with the following example:\n\nJava String Tutorial\n\nJava String Methods\n\nString originalStr = \"Hello\";\nString reversedStr = \"\";\n\nfor (int i = 0; i < originalStr.length(); i++) {\n  reversedStr = originalStr.charAt(i) + reversedStr;\n}\n\nSystem.out.println(\"Reversed string: \"+ reversedStr);\nString originalStr = \"Hello\";\nString reversedStr = \"\";\n\nfor (int i = 0; i < originalStr.length(); i++) {\n  reversedStr = originalStr.charAt(i) + reversedStr;\n}\n\nSystem.out.println(\"Reversed string: \"+ reversedStr);",
  "Java How To Calculate the Sum of Elements\n\nGet the sum of array elements:\n\nint[] myArray = {1, 5, 10, 25};\nint sum = 0;\nint i; \n\n// Loop through the array elements and store the sum in the sum variable\nfor (i = 0; i < myArray.length; i++) {\n  sum += myArray[i];\n}\n\nSystem.out.println(\"The sum is: \" + sum);\nint[] myArray = {1, 5, 10, 25};\nint sum = 0;\nint i; \n\n// Loop through the array elements and store the sum in the sum variable\nfor (i = 0; i < myArray.length; i++) {\n  sum += myArray[i];\n\n\n\nSystem.out.println(\"The sum is: \" + sum);",
  "Java How To Convert a String to an Array\n\nThere are many ways to convert a string to an array. The simplest way is to use the toCharArray() method:\n\nConvert a string to a char array:\n\nYou can also loop through the array to print all array elements:\n\nJava Strings Tutorial\n\nJava Array Tutorial\n\nThe toCharArray() String Method\n\n// Create a string\nString myStr = \"Hello\";\n\n// Convert the string to a char array\nchar[] myArray = myStr.toCharArray();\n\n// Print the first element of the array\nSystem.out.println(myArray[0]);\n// Create a string\nString myStr = \"Hello\";\n\n// Convert the string to a char array\nchar[] myArray = myStr.toCharArray();\n\n// Print array elements\nfor (char i : myArray) {\n  System.out.println(i);\n}\ntoCharArray()\nchar\n// Create a string\nString myStr = \"Hello\";\n\n// Convert the string to a char array\nchar[] myArray = myStr.toCharArray();\n\n// Print the first element of the array\nSystem.out.println(myArray[0]);\n// Create a string\nString myStr = \"Hello\";\n\n// Convert the string to a char array\nchar[] myArray = myStr.toCharArray();\n\n// Print array elements\nfor (char i : myArray) {\n  System.out.println(i);\n}",
  "Java How To Sort an Array\n\nYou can use the sort() method, found in java.util.Arrays, to sort an array:\n\nTry it Yourself »\n\nJava Array Tutorial\n\nJava Arrays Class Reference\n\nimport java.util.Arrays;\n\npublic class Main {\n  public static void main(String[] args) {\n    String[] cars = {\"Volvo\", \"BMW\", \"Tesla\", \"Ford\", \"Fiat\", \"Mazda\", \"Audi\"};\n    Arrays.sort(cars);\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nsort()\njava.util.Arrays\nimport java.util.Arrays;\n\npublic class Main {\n  public static void main(String[] args) {\n    String[] cars = {\"Volvo\", \"BMW\", \"Tesla\", \"Ford\", \"Fiat\", \"Mazda\", \"Audi\"};\n    Arrays.sort(cars);\n    for (String i : cars) {\n      System.out.println(i);\n    \n\n  \n\n\n\n",
  "Java How To Find the Average of Array Elements\n\nCreate a program that calculates the average of different ages:\n\nTry it Yourself »\n\nJava Array Tutorial\n\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Loop through the elements of the array\nfor (int age : ages) {\n  sum += age;\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nSystem.out.println(\"The average age is: \" + avg);\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\nfloat avg, sum = 0;\n\n// Get the length of the array\nint length = ages.length;\n\n// Loop through the elements of the array\nfor (int age : ages) {\n  sum += age;\n}\n\n// Calculate the average by dividing the sum by the length\navg = sum / length;\n\n// Print the average\nSystem.out.println(\"The average age is: \" + avg);",
  "Java How To Find the Smallest Element in an Array\n\nCreate a program that finds the lowest age among different ages:\n\nTry it Yourself »\n\nJava Array Tutorial\n\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\n// Create a 'lowest age' variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int age : ages) {\n  // Check if the current age is smaller than the current 'lowest age'\n  if (lowestAge > age) {\n    // If the smaller age is found, update 'lowest age' with that element\n    lowestAge = age;\n  }\n}\n\n// Output the value of the lowest age\nSystem.out.println(\"The lowest age in the array is: \" + lowestAge);\n// An array storing different ages\nint ages[] = {20, 22, 18, 35, 48, 26, 87, 70};\n\n// Create a 'lowest age' variable and assign the first array element of ages to it\nint lowestAge = ages[0];\n\n// Loop through the elements of the ages array to find the lowest age\nfor (int age : ages) {\n  // Check if the current age is smaller than the current 'lowest age'\n  if (lowestAge > age) {\n    // If the smaller age is found, update 'lowest age' with that element\n    lowestAge = age;\n  }\n}\n\n// Output the value of the lowest age\nSystem.out.println(\"The lowest age in the array is: \" + lowestAge);",
  "Java How To Loop Through an ArrayList\n\nLoop through the elements of an ArrayList:\n\nTry it Yourself »\n\nJava ArrayList Tutorial\n\nJava ArrayList Methods\n\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n\nArrayList\npublic class Main {\n  public static void main(String[] args) {\n    ArrayList<String> cars = new ArrayList<String>();\n    cars.add(\"Volvo\");\n    cars.add(\"BMW\");\n    cars.add(\"Ford\");\n    cars.add(\"Mazda\");\n    for (String i : cars) {\n      System.out.println(i);\n    }\n  }\n}\n",
  "Java How To Loop Through a HashMap\n\nLoop through the items of a HashMap with a for-each loop.\n\nNote: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:\n\nTry it Yourself »\n\nTry it Yourself »\n\nTry it Yourself »\n\nJava HashMap Tutorial\n\nJava HashMap Methods\n\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\n\nHashMap\nkeySet()\nvalues()\n// Print keys\nfor (String i : capitalCities.keySet()) {\n  System.out.println(i);\n}\n\n// Print values\nfor (String i : capitalCities.values()) {\n  System.out.println(i);\n}\n\n// Print keys and values\nfor (String i : capitalCities.keySet()) {\n  System.out.println(\"key: \" + i + \" value: \" + capitalCities.get(i));\n}\n",
  "Java How To Loop Through an Enum\n\nThe enum type has a values() method, which returns an array of all enum constants. This method is useful when you want to loop through the constants of an enum:\n\nJava Enums Tutorial\n\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    for (Level myVar : Level.values()) {\n      System.out.println(myVar);\n    }\n  } \n}\nvalues()\nenum Level {\n  LOW,\n  MEDIUM,\n  HIGH\n}\n\npublic class Main { \n  public static void main(String[] args) { \n    for (Level myVar : Level.values()) {\n      System.out.println(myVar);\n    }\n  } \n}",
  "Java How To Get the Area of a Rectangle\n\nThe area of a rectangle can be found by multiplying the length of the rectangle by the width:\n\nint length = 5; \nint width = 2; \nint area = length * width; \nSystem.out.println(\"Area of rectangle: \" + area); \nint length = 5; \nint width = 2; \nint area = length * width; \nSystem.out.println(\"Area of rectangle: \" + area); ",
  "Java How To Find Even or Odd Numbers\n\nFind out if a number is even or odd:\n\nJava Numbers Tutorial\n\nJava Operators Tutorial\n\nJava Math Tutorial\n\nint number = 5;\n\n// Find out if the number above is even or odd\nif (number % 2 == 0) {\n  System.out.println(number + \" is even.\");\n} else {\n  System.out.println(number + \" is odd.\");\n}\nint number = 5;\n\n// Find out if the number above is even or odd\nif (number % 2 == 0) {\n  System.out.println(number + \" is even.\");\n} else {\n  System.out.println(number + \" is odd.\");\n",
  "Java How To Find Positive or Negative Numbers\n\nFind out if a number is even or odd:\n\nJava If..Else Tutorial\n\nint myNum = 10; // Is this a positive or negative number?\n\nif (myNum > 0) {\n  System.out.println(\"The value is a positive number.\");\n} else if (myNum < 0) {\n  System.out.println(\"The value is a negative number.\");\n} else {\n  System.out.println(\"The value is 0.\");\n}\nint myNum = 10; // Is this a positive or negative number?\n\nif (myNum > 0) {\n  System.out.println(\"The value is a positive number.\");\n} else if (myNum < 0) {\n  System.out.println(\"The value is a negative number.\");\n} else {\n  System.out.println(\"The value is 0.\");\n",
  "Java How To Find the Square Root of a Number\n\nYou can use Math.sqrt() to find the square root of a number:\n\nFind the square root of 64:\n\nJava Math Tutorial\n\nJava Math Reference\n\nMath.sqrt(64);\nMath.sqrt()\nMath.sqrt(64);",
  "Java How To Generate Random Numbers\n\nYou can use Math.random() method to generate a random number. Math.random() returns a random number between 0.0 (inclusive), and 1.0 (exclusive): Example Math.random(); Try it Yourself » To get more control over the random number, for example, if you only want a random number between 0 and 100, you can use the following formula: Example int randomNum = (int)(Math.random() * 101); // 0 to 100 Try it Yourself » Related Pages Java Math Tutorial Java Math Reference Java Type Casting ❮ Previous Next ❯ ★ +1 Track your progress - it's free! Log in Sign Up\n\nMath.random() returns a random number between 0.0 (inclusive), and 1.0 (exclusive):\n\nTry it Yourself »\n\nTo get more control over the random number, for example, if you only want a random number between 0 and 100, you can use the following formula:\n\nTry it Yourself »\n\nJava Math Tutorial\n\nJava Math Reference\n\nJava Type Casting\n\nMath.random();\nint randomNum = (int)(Math.random() * 101); // 0 to 100\nMath.random()\nMath.random()\nMath.random();\nint randomNum = (int)(Math.random() * 101); // 0 to 100",
  "Java Reference Documentation\n\nThis section contains a Java reference documentation.\n\nA list of Java keywords and methods can be found here:",
  "Java Keywords\n\nJava has a set of keywords that are reserved words that cannot be used as variables, methods, classes, or any other identifiers:\n\nNote: true, false, and null are not keywords, but they are literals and reserved words that cannot be used as identifiers.\n\ntrue\nfalse\nnull",
  "Java String Methods\n\nThe String class has a set of built-in methods that you can use on strings.\n\nJava Strings Tutorial",
  "Java Math Methods\n\nThe Java Math class has many methods that allows you to perform mathematical tasks on numbers.\n\nA list of all Math methods can be found in the table below:\n\nNote: All Math methods are static.\n\nJava Math Tutorial\n\nstatic",
  "Java Output Methods\n\nThe System.out stream, short for \"output\", is used together with different methods to output values or print text to the console:\n\nSystem.out",
  "Java Arrays Class\n\nThe Java Arrays class (found in java.util), has methods that allow you to manipulate arrays.\n\nA list of popular methods of the Arrays Class can be found in the table below:\n\nThe length property is a built-in Java property, and does not belong to the Arrays class.\n\nJava Arrays Tutorial\n\nArrays\njava.util\nlength",
  "Java ArrayList Methods\n\nA list of all ArrayList methods can be found in the table below.\n\nSome methods use the type of the ArrayList's items as a parameter or return value. This type will be referred to as T in the table.\n\nJava Arrays Tutorial\n\nJava ArrayList Tutorial\n\nIterator\nArrayList\nListIterator\nArrayList\nSpliterator\nArrayList",
  "Java LinkedList Methods\n\nA list of all LinkedList methods can be found in the table below.\n\nSome methods use the type of the LinkedList's items as a parameter or return value. This type will be referred to as T in the table.\n\nJava Arrays Tutorial\n\nJava LinkedList Tutorial\n\nJava ArrayList Tutorial\n\ngetFirst()\nIterator\n\n    LinkedList\nListIterator\n\n    LinkedList\ngetFirst()\npeek()\npoll()\nremoveFirst()\naddFirst()\nSpliterator\n\n    LinkedList",
  "Java HashMap Methods\n\nA list of all HashMap methods can be found in the table below.\n\nSome methods use the type of the HashMap's entries as a parameter or return value. The type of the key will be referred to as K and the type of the value will be referred to as V in the table.\n\nJava HashMap Tutorial",
  "Java Scanner Methods\n\nThe Scanner class can be used to obtain data from the keyboard, files and strings.\n\nA list of useful Scanner methods can be found in the table below.\n\nScanner\nScanner\nbyte\nint\nlong\nshort\nbyte\ndouble\nfloat\nint\nlong\nshort",
  "Java Iterator Interface\n\nThe Iterator interface provides methods to access and iterate through collections:\n\nNote: The next() method uses the type of the iterator's items as its return value. This type is referred to as T in the table.\n\nIterator\nnext()",
  "Java Errors and Exception Types\n\nThe table below shows a list of common Error and Exception types in Java:\n\nError\nException\nnull",
  "Java Examples\n\n",
  "Java Online Compiler\n\nWith our online Java compiler, you can edit Java code, and view the result in your browser.\n\nClick on the \"Try it Yourself\" button to see how it works.\n\nIf you want to create your own Java applications, check out W3Schools Spaces.\n\nW3Schools Spaces is a website-building tool that enables you to create and share your own website, as well as develop and host Java applications.\n\nYou can change the website's look and how it works by editing the code right in your web browser.\n\nIt's easy to use and doesn't require any setup.\n\nThe code editor is packed with features to help you achieve more:\n\nPractice is key to mastering coding, and the best way to put your Java knowledge into practice is by getting practical with code.\n\nUse W3Schools Spaces to build, test and deploy code.\n\nThe code editor lets you write and practice different types of computer languages. It includes Java, but you can use it for other languages too.\n\nNew languages are added all the time:\n\nIf you don't know Java, we suggest that you read our Java Tutorial from scratch.\n\nGet an overview of your packages and easily add or delete frameworks and libraries. Then, with just one click, you can make changes to your packages without manual installation.\n\nYou can also use the code editor in W3School Spaces to build frontend or full-stack websites from scratch.\n\nOr you can use the 60+ templates available and save time:\n\nCreate your Spaces account today and explore them all!\n\nHost and publish your websites in no time with W3School Spaces.\n\nW3Schools subdomain and SSL certificate are included for free with W3School Spaces. An SSL certificate makes your website safe and secure. It also helps people trust your website and makes it easier to find it online.\n\nWant a custom domain for your website?\n\nYou can buy a domain or transfer an existing one and connect it to your space.\n\nGet started in a few clicks with W3School Spaces.\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World!\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World!\");\n  }\n}\n\nHello World!",
  "Java Exercises\n\nTest your Java skills with exercises from all categories:\n\nIf you haven't already, sign up to become a W3Schooler, and get points for every exercise you complete.\n\nAs a logged-in W3Schools user you will have access to many features like having your own web page, track your learning progress, receive personal guided paths, and more.\n\nThe exercises are a mix of \"multiple choice\" and \"fill in the blanks\" questions. There are between 3 and 9 questions in each category. The answer can be found in the corresponding tutorial chapter. If you're stuck, or answer wrong, you can try again or hit the \"Show Answer\" button to see the correct answer.\n\nGet certified by completing the course",
  "Java Quiz\n\nYou can test your Java skills with W3Schools' Quiz.\n\nThe test contains 25 questions and there is no time limit.\n\nThe test is not official, it's just a nice way to see how much you know, or don't know, about Java.\n\nYou will get 1 point for each correct answer. At the end of the Quiz, your total score will be displayed. Maximum score is 25 points.\n\nGood luck!\n\nStart the Java Quiz ❯\n\nIf you don't know Java, we suggest that you read our Java Tutorial from scratch.\n\nGet certified by completing the course",
  "Java Server\n\nCoding Skills\n\nAI Tutor\n\nProjects\n\nSecurely\n\nBy subscribing to a plan you support the W3Schools mission to make learning available to everyone - no matter their background.\n\n$0 /Forever\n\nThis is for you that are beginning to explore coding and web development\n\n$14.99 /Month\n\nThis is for you that want to learn and reach your goals faster. Build fullstack projects, ad free experience.\n\nFor teachers\n\nSpend less time on admin tasks while engaging your students. Help them learn, practice and collaborate. All in one place.\n\nYou can also buy a domain or connect an existing one.\n\nJust landed in Spaces\n\nLearn to code more effectively and intelligently with kAI - AI tutor\n\nHi! I'm kAI, W3Schools AI Tutor...\n\nFeel free to ask me any coding-related questions, and I'll do my best to assist you.\n\nI can help you checking your code for errors, improving your code's structure, explaining coding concepts in a clear and understandable way, and more...\n\nI can even create complete websites for you based on your input, so what are you waiting for?\n\nCloud-based\n\nTerminal & Log\n\nHow To Libraries\n\nDatabase\n\nFile Navigator\n\nPackage Manager\n\nAnalytics\n\nEnvironment Manager\n\nWith Basic Spaces, you can build frontend websites. Whereas with Fullstack Spaces, you can build frontend and backend websites.\n\nBasic Spaces include HTML, CSS, and Javascript. Full Stack Spaces include everything in Basic Spaces plus PHP, Python, React.js, Vue.js, Node.js, Handlebars, and Django.\n\nYour subscription will be automatically renewed every month.\n\nYour access to all the benefits for the paid period of time will continue. However, the subscription will not be renewed automatically.\n\nTo subscribe W3Schools accounts for multiple users, you can contact sales@w3schools.com",
  "Java Syllabus\n\nThe W3Schools Java Tutorial is comprehensive and beginner-friendly.\n\nIt will give you a fundamental knowledge of Java.\n\nIt is designed for beginners and requires no prior experience with programming.\n\nThe content has been carefully made to be bite-sized, simple, and easy to understand.\n\nThe content has been proven by millions of users over the years. It is updated and improved frequently.\n\nThe syllabus outline and its sequence are structured so you can learn Java step by step, from the introduction to creating your first application with Java.\n\nGet Started With Java »\n\nNote: Are you a teacher teaching Java? W3Schools Academy is a toolbox of features that can help you teach. It offers classroom features such as pre-built study plans, classroom administration and much more. Read more about Academy here.\n\nGet Started\n\nIn this tutorial we offer different activities for you to learn Java for free:\n\nYou can also create a free account to track your progress.\n\nAs a signed-in user, you get access to features such as:\n\nSign Up - It's free\n\nGet Started\n\nJava, like any other coding language, is best learned by working hands-on with code.\n\nEasily try code with our \"Try it Yourself\" editor.\n\nHere, you can edit Java code and view the result.\n\nTry it Yourself »\n\nIf you want to explore more and host your project, we have a feature called Spaces that allows you to build, test and deploy Java code and other backend languages.\n\nHere you get a secure sandbox environment called Spaces, where you can practice coding and test projects in real-time.\n\nSpaces allow you to test, build, and deploy code. This includes a W3Schools subdomain, hosting, and secure SSL certificates.\n\nSpaces require no installation and run directly in the browser.\n\nFeatures include:\n\nCreate a Spaces Account\n\nW3Schools offers an end-of-pathway certification program.\n\nHere you can take exams to get certified.\n\nThe Java exam is a test that summarizes the W3Schools Java syllabus.\n\nAfter passing the exam you get the \"Certified Java Developer\" Certification.\n\nThere are two different types of certifications:\n\nThe non-adaptive is pass or no pass.\n\nThe adaptive certification is adaptive and graded; students will get a grade from intermediate, advanced to professional.\n\nBuy Certificate »\n\nAre you interested in learning how you can use W3Schools Academy to Teach Java?\n\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\n\nWatch Demo »\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}\n",
  "Java Study Plan\n\nThe Java study plan helps you teach your students Java step-by-step.\n\nCreating a study plan for Java is easy.\n\nYou can use a pre-built study plan or customize it.\n\nStudents have different skill levels. The study plans can be customized to ensure that everyone is challenged.\n\nSave time with pre-built teacher materials and study plans. Easily organize your class with a timeline from the introduction of Java to the final exam.\n\nThis study plan is a feature of W3Schools Academy.\n\nW3Schools Academy is a platform that has everything you need to teach coding, all in one place.\n\nIt offers you as a teacher a toolbox of features that helps you succeed with teaching in your classroom.\n\nYou need to have an active subscription to access the study plan feature. There are two different subscription tiers:\n\nLearn More »\n\nAcademy also offer other features such as:\n\nGet a free demo »\n\nW3Schools has everything you need to teach Java.\n\nThe Java training materials is available for you to include and use in your study plan:\n\nWith the Java Syllabus, your students will start with the basics, like understanding variables, data types, and simple object-oriented programming concepts, and move to more advanced topics, like working with classes, inheritance, and handling exceptions. Each chapter has examples, try-it-yourself sections, exercises, and quizzes to make learning easy, interactive, and fun.\n\nRead more about Java Syllabus.\n\nThe study plan features are made to help teachers and students. They make learning easy, flexible, and fun. These features work for different types of classes, learning styles and student level.\n\nLearn More »\n\nYou choose the timeline and pace of your study plans.\n\nSchools have different preferences.\n\nSome would like more intensive pace, e.g. 5 weeks, others 12 or more weeks.\n\nIt is completely up to you.\n\nFor example, this is how a 5-week Java study plan could look like:\n\nImage of Sample Java study plan:\n\nStart with Java Study Plans today.\n\nGet Started »\n\nAre you interested in learning how you can use W3Schools Academy to Teach Java programming?\n\nWatch a demo of W3Schools Academy. You'll see how it works, and discover how it can make teaching programming easier and more engaging.\n\nWatch Demo »",
  "W3Schools Java Certificate\n\nW3Schools offers an Online Certification Program.\n\nThe perfect solution for busy professionals who need to balance work, family, and career building.\n\nMore than 50 000 certificates already issued!\n\nGet Your Certificate »\n\nW3Schools offers an Online Certification Program.\n\nThe perfect solution for busy professionals who need to balance work, family, and career building.\n\nMore than 50 000 certificates already issued!\n\nGet Your Certificate »\n\nAny student or professional within the digital industry.\n\nCertifications are valuable assets to gain trust and demonstrate knowledge to your clients, current or future employers on a ever increasing competitive market.\n\nW3Schools has over two decades of experience with teaching coding online.\n\nOur certificates are recognized and valued by companies looking to employ skilled developers.\n\nShow the world your coding skills by getting a certification.\n\nThe prices is a small fraction compared to the price of traditional education.\n\nDocument and validate your competence by getting certified!\n\nFee: 95 USD\n\nAchievable certification levels: Intermediate (40%) Advanced (75%) Professional (90%)\n\nNumber of questions: Adaptive, 60 on average\n\nRequirement to pass: Minimum 40% - Intermediate level\n\nTime limit: 60 minutes\n\nNumber of attempts to pass: 3\n\nExam deadline: None\n\nCertification Expiration: None\n\nFormat: Online, multiple choice\n\nRegister now »\n\nGetting a certificate proves your commitment to upgrading your skills.\n\nThe certificate can be added as credentials to your CV, Resume, LinkedIn profile, and so on.\n\nIt gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\n\nKnowledge is power, especially in the current job market.\n\nDocumentation of your skills enables you to advance your career or helps you to start a new one.\n\nExample certificate:\n\nEach certificate gets a unique link that can be shared with others.\n\nValidate your certification with the link or QR code.\n\nCheck how it looks like in this Example.\n\nShare your certificate on Linked in the Certifications section in just one click!\n\nGetting a certificate proves your commitment to upgrade your skills, gives you the credibility needed for more responsibilities, larger projects, and a higher salary.\n\nGet Your Certificate »\n\nAre you an educator, manager or business owner looking for courses or certifications?\n\nWe are working with schools, companies and organizations from all over the world.\n\nGet courses and/or certifications for your team here."
]